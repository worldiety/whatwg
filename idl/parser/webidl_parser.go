// Code generated from WebIDL by ANTLR 4.7.2. DO NOT EDIT.

package parser // WebIDL

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 88, 832,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 3, 2, 3, 2, 3, 2, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 209, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 4, 5, 4, 217, 10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 223, 10, 5, 3,
	6, 3, 6, 5, 6, 227, 10, 6, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3,
	7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3,
	10, 3, 10, 5, 10, 250, 10, 10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11,
	3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 264, 10, 12, 3, 13, 3,
	13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 276,
	10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 15,
	3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 291, 10, 15, 3, 16, 3, 16, 3, 16, 3,
	16, 3, 16, 3, 16, 3, 17, 3, 17, 5, 17, 301, 10, 17, 3, 18, 3, 18, 3, 18,
	3, 18, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 5, 19, 313, 10, 19, 3,
	20, 3, 20, 3, 20, 3, 20, 5, 20, 319, 10, 20, 3, 21, 3, 21, 3, 21, 5, 21,
	324, 10, 21, 3, 22, 3, 22, 3, 22, 5, 22, 329, 10, 22, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25,
	5, 25, 344, 10, 25, 3, 26, 3, 26, 3, 26, 5, 26, 349, 10, 26, 3, 27, 3,
	27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3, 28,
	3, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 3, 31, 5, 31, 380, 10, 31, 3, 32,
	3, 32, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3,
	35, 3, 35, 5, 35, 395, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36,
	3, 36, 3, 36, 3, 36, 5, 36, 406, 10, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	37, 3, 37, 5, 37, 414, 10, 37, 3, 38, 3, 38, 3, 38, 3, 38, 5, 38, 420,
	10, 38, 3, 39, 3, 39, 3, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40,
	3, 40, 5, 40, 432, 10, 40, 3, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3,
	42, 3, 42, 3, 42, 5, 42, 443, 10, 42, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44,
	3, 44, 5, 44, 451, 10, 44, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 5, 45, 458,
	10, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 47, 3, 47, 5, 47, 467, 10,
	47, 3, 48, 3, 48, 3, 49, 3, 49, 5, 49, 473, 10, 49, 3, 50, 3, 50, 5, 50,
	477, 10, 50, 3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 483, 10, 51, 3, 52, 3,
	52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 494, 10, 53,
	3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 56, 3, 56, 5,
	56, 506, 10, 56, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57, 512, 10, 57, 3, 58,
	3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 519, 10, 58, 3, 59, 3, 59, 3, 59, 3,
	60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60, 533,
	10, 60, 3, 61, 3, 61, 5, 61, 537, 10, 61, 3, 62, 3, 62, 5, 62, 541, 10,
	62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64,
	5, 64, 553, 10, 64, 3, 65, 3, 65, 3, 66, 3, 66, 3, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68,
	3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5, 69, 579, 10, 69, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 70, 5, 70, 586, 10, 70, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 5, 71, 606, 10, 71, 3, 72, 3, 72, 5, 72, 610,
	10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 5,
	73, 631, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74,
	3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 5, 74, 674, 10, 74, 3, 75, 3, 75, 3, 76, 3, 76, 5, 76, 680,
	10, 76, 3, 77, 3, 77, 3, 77, 3, 77, 5, 77, 686, 10, 77, 3, 78, 3, 78, 5,
	78, 690, 10, 78, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 3, 80,
	3, 80, 3, 80, 3, 80, 5, 80, 703, 10, 80, 3, 81, 3, 81, 3, 81, 3, 81, 3,
	81, 5, 81, 710, 10, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 747, 10, 82, 3,
	83, 3, 83, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 5, 84, 756, 10, 84, 3, 85,
	3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 763, 10, 85, 3, 86, 3, 86, 3, 86, 5,
	86, 768, 10, 86, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 5, 88, 775, 10, 88,
	3, 89, 3, 89, 3, 89, 5, 89, 780, 10, 89, 3, 90, 3, 90, 5, 90, 784, 10,
	90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 3, 92, 3, 92, 5, 92, 793, 10, 92,
	3, 93, 3, 93, 5, 93, 797, 10, 93, 3, 94, 3, 94, 3, 94, 3, 95, 3, 95, 3,
	95, 3, 95, 5, 95, 806, 10, 95, 3, 96, 3, 96, 3, 97, 3, 97, 3, 97, 3, 97,
	3, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 3, 99, 3,
	99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 3, 100, 2,
	2, 101, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
	36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
	72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
	106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
	136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
	166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
	196, 198, 2, 8, 3, 2, 25, 26, 4, 2, 27, 29, 83, 83, 4, 2, 31, 31, 37, 39,
	11, 2, 3, 4, 9, 11, 17, 17, 21, 23, 30, 34, 36, 39, 42, 42, 45, 46, 68,
	68, 3, 2, 70, 80, 3, 2, 58, 59, 2, 869, 2, 200, 3, 2, 2, 2, 4, 208, 3,
	2, 2, 2, 6, 216, 3, 2, 2, 2, 8, 222, 3, 2, 2, 2, 10, 226, 3, 2, 2, 2, 12,
	228, 3, 2, 2, 2, 14, 236, 3, 2, 2, 2, 16, 244, 3, 2, 2, 2, 18, 249, 3,
	2, 2, 2, 20, 251, 3, 2, 2, 2, 22, 263, 3, 2, 2, 2, 24, 275, 3, 2, 2, 2,
	26, 277, 3, 2, 2, 2, 28, 290, 3, 2, 2, 2, 30, 292, 3, 2, 2, 2, 32, 300,
	3, 2, 2, 2, 34, 302, 3, 2, 2, 2, 36, 312, 3, 2, 2, 2, 38, 318, 3, 2, 2,
	2, 40, 323, 3, 2, 2, 2, 42, 328, 3, 2, 2, 2, 44, 330, 3, 2, 2, 2, 46, 337,
	3, 2, 2, 2, 48, 343, 3, 2, 2, 2, 50, 348, 3, 2, 2, 2, 52, 350, 3, 2, 2,
	2, 54, 358, 3, 2, 2, 2, 56, 363, 3, 2, 2, 2, 58, 368, 3, 2, 2, 2, 60, 379,
	3, 2, 2, 2, 62, 381, 3, 2, 2, 2, 64, 383, 3, 2, 2, 2, 66, 385, 3, 2, 2,
	2, 68, 394, 3, 2, 2, 2, 70, 405, 3, 2, 2, 2, 72, 413, 3, 2, 2, 2, 74, 419,
	3, 2, 2, 2, 76, 421, 3, 2, 2, 2, 78, 431, 3, 2, 2, 2, 80, 433, 3, 2, 2,
	2, 82, 442, 3, 2, 2, 2, 84, 444, 3, 2, 2, 2, 86, 450, 3, 2, 2, 2, 88, 457,
	3, 2, 2, 2, 90, 459, 3, 2, 2, 2, 92, 466, 3, 2, 2, 2, 94, 468, 3, 2, 2,
	2, 96, 472, 3, 2, 2, 2, 98, 476, 3, 2, 2, 2, 100, 482, 3, 2, 2, 2, 102,
	484, 3, 2, 2, 2, 104, 493, 3, 2, 2, 2, 106, 495, 3, 2, 2, 2, 108, 497,
	3, 2, 2, 2, 110, 505, 3, 2, 2, 2, 112, 511, 3, 2, 2, 2, 114, 518, 3, 2,
	2, 2, 116, 520, 3, 2, 2, 2, 118, 532, 3, 2, 2, 2, 120, 536, 3, 2, 2, 2,
	122, 540, 3, 2, 2, 2, 124, 542, 3, 2, 2, 2, 126, 552, 3, 2, 2, 2, 128,
	554, 3, 2, 2, 2, 130, 556, 3, 2, 2, 2, 132, 558, 3, 2, 2, 2, 134, 566,
	3, 2, 2, 2, 136, 578, 3, 2, 2, 2, 138, 585, 3, 2, 2, 2, 140, 605, 3, 2,
	2, 2, 142, 609, 3, 2, 2, 2, 144, 630, 3, 2, 2, 2, 146, 673, 3, 2, 2, 2,
	148, 675, 3, 2, 2, 2, 150, 679, 3, 2, 2, 2, 152, 685, 3, 2, 2, 2, 154,
	689, 3, 2, 2, 2, 156, 691, 3, 2, 2, 2, 158, 702, 3, 2, 2, 2, 160, 709,
	3, 2, 2, 2, 162, 746, 3, 2, 2, 2, 164, 748, 3, 2, 2, 2, 166, 755, 3, 2,
	2, 2, 168, 762, 3, 2, 2, 2, 170, 767, 3, 2, 2, 2, 172, 769, 3, 2, 2, 2,
	174, 774, 3, 2, 2, 2, 176, 779, 3, 2, 2, 2, 178, 783, 3, 2, 2, 2, 180,
	785, 3, 2, 2, 2, 182, 792, 3, 2, 2, 2, 184, 796, 3, 2, 2, 2, 186, 798,
	3, 2, 2, 2, 188, 805, 3, 2, 2, 2, 190, 807, 3, 2, 2, 2, 192, 809, 3, 2,
	2, 2, 194, 814, 3, 2, 2, 2, 196, 818, 3, 2, 2, 2, 198, 824, 3, 2, 2, 2,
	200, 201, 5, 4, 3, 2, 201, 202, 7, 2, 2, 3, 202, 3, 3, 2, 2, 2, 203, 204,
	5, 136, 69, 2, 204, 205, 5, 6, 4, 2, 205, 206, 5, 4, 3, 2, 206, 209, 3,
	2, 2, 2, 207, 209, 3, 2, 2, 2, 208, 203, 3, 2, 2, 2, 208, 207, 3, 2, 2,
	2, 209, 5, 3, 2, 2, 2, 210, 217, 5, 8, 5, 2, 211, 217, 5, 16, 9, 2, 212,
	217, 5, 26, 14, 2, 213, 217, 5, 44, 23, 2, 214, 217, 5, 54, 28, 2, 215,
	217, 5, 56, 29, 2, 216, 210, 3, 2, 2, 2, 216, 211, 3, 2, 2, 2, 216, 212,
	3, 2, 2, 2, 216, 213, 3, 2, 2, 2, 216, 214, 3, 2, 2, 2, 216, 215, 3, 2,
	2, 2, 217, 7, 3, 2, 2, 2, 218, 219, 7, 3, 2, 2, 219, 223, 5, 10, 6, 2,
	220, 223, 5, 12, 7, 2, 221, 223, 5, 14, 8, 2, 222, 218, 3, 2, 2, 2, 222,
	220, 3, 2, 2, 2, 222, 221, 3, 2, 2, 2, 223, 9, 3, 2, 2, 2, 224, 227, 5,
	52, 27, 2, 225, 227, 5, 12, 7, 2, 226, 224, 3, 2, 2, 2, 226, 225, 3, 2,
	2, 2, 227, 11, 3, 2, 2, 2, 228, 229, 7, 4, 2, 2, 229, 230, 7, 84, 2, 2,
	230, 231, 5, 40, 21, 2, 231, 232, 7, 5, 2, 2, 232, 233, 5, 22, 12, 2, 233,
	234, 7, 6, 2, 2, 234, 235, 7, 7, 2, 2, 235, 13, 3, 2, 2, 2, 236, 237, 7,
	8, 2, 2, 237, 238, 7, 84, 2, 2, 238, 239, 5, 42, 22, 2, 239, 240, 7, 5,
	2, 2, 240, 241, 5, 22, 12, 2, 241, 242, 7, 6, 2, 2, 242, 243, 7, 7, 2,
	2, 243, 15, 3, 2, 2, 2, 244, 245, 7, 9, 2, 2, 245, 246, 5, 18, 10, 2, 246,
	17, 3, 2, 2, 2, 247, 250, 5, 20, 11, 2, 248, 250, 5, 34, 18, 2, 249, 247,
	3, 2, 2, 2, 249, 248, 3, 2, 2, 2, 250, 19, 3, 2, 2, 2, 251, 252, 7, 4,
	2, 2, 252, 253, 7, 84, 2, 2, 253, 254, 7, 5, 2, 2, 254, 255, 5, 22, 12,
	2, 255, 256, 7, 6, 2, 2, 256, 257, 7, 7, 2, 2, 257, 21, 3, 2, 2, 2, 258,
	259, 5, 136, 69, 2, 259, 260, 5, 24, 13, 2, 260, 261, 5, 22, 12, 2, 261,
	264, 3, 2, 2, 2, 262, 264, 3, 2, 2, 2, 263, 258, 3, 2, 2, 2, 263, 262,
	3, 2, 2, 2, 264, 23, 3, 2, 2, 2, 265, 276, 5, 58, 30, 2, 266, 276, 5, 100,
	51, 2, 267, 276, 5, 66, 34, 2, 268, 276, 5, 76, 39, 2, 269, 276, 5, 80,
	41, 2, 270, 276, 5, 124, 63, 2, 271, 276, 5, 84, 43, 2, 272, 276, 5, 88,
	45, 2, 273, 276, 5, 128, 65, 2, 274, 276, 5, 130, 66, 2, 275, 265, 3, 2,
	2, 2, 275, 266, 3, 2, 2, 2, 275, 267, 3, 2, 2, 2, 275, 268, 3, 2, 2, 2,
	275, 269, 3, 2, 2, 2, 275, 270, 3, 2, 2, 2, 275, 271, 3, 2, 2, 2, 275,
	272, 3, 2, 2, 2, 275, 273, 3, 2, 2, 2, 275, 274, 3, 2, 2, 2, 276, 25, 3,
	2, 2, 2, 277, 278, 7, 10, 2, 2, 278, 279, 7, 84, 2, 2, 279, 280, 5, 40,
	21, 2, 280, 281, 7, 5, 2, 2, 281, 282, 5, 28, 15, 2, 282, 283, 7, 6, 2,
	2, 283, 284, 7, 7, 2, 2, 284, 27, 3, 2, 2, 2, 285, 286, 5, 136, 69, 2,
	286, 287, 5, 30, 16, 2, 287, 288, 5, 28, 15, 2, 288, 291, 3, 2, 2, 2, 289,
	291, 3, 2, 2, 2, 290, 285, 3, 2, 2, 2, 290, 289, 3, 2, 2, 2, 291, 29, 3,
	2, 2, 2, 292, 293, 5, 32, 17, 2, 293, 294, 5, 152, 77, 2, 294, 295, 7,
	84, 2, 2, 295, 296, 5, 36, 19, 2, 296, 297, 7, 7, 2, 2, 297, 31, 3, 2,
	2, 2, 298, 301, 7, 11, 2, 2, 299, 301, 3, 2, 2, 2, 300, 298, 3, 2, 2, 2,
	300, 299, 3, 2, 2, 2, 301, 33, 3, 2, 2, 2, 302, 303, 7, 10, 2, 2, 303,
	304, 7, 84, 2, 2, 304, 305, 7, 5, 2, 2, 305, 306, 5, 28, 15, 2, 306, 307,
	7, 6, 2, 2, 307, 308, 7, 7, 2, 2, 308, 35, 3, 2, 2, 2, 309, 310, 7, 12,
	2, 2, 310, 313, 5, 38, 20, 2, 311, 313, 3, 2, 2, 2, 312, 309, 3, 2, 2,
	2, 312, 311, 3, 2, 2, 2, 313, 37, 3, 2, 2, 2, 314, 319, 5, 60, 31, 2, 315,
	319, 7, 85, 2, 2, 316, 317, 7, 13, 2, 2, 317, 319, 7, 14, 2, 2, 318, 314,
	3, 2, 2, 2, 318, 315, 3, 2, 2, 2, 318, 316, 3, 2, 2, 2, 319, 39, 3, 2,
	2, 2, 320, 321, 7, 15, 2, 2, 321, 324, 7, 84, 2, 2, 322, 324, 3, 2, 2,
	2, 323, 320, 3, 2, 2, 2, 323, 322, 3, 2, 2, 2, 324, 41, 3, 2, 2, 2, 325,
	326, 7, 16, 2, 2, 326, 329, 7, 84, 2, 2, 327, 329, 3, 2, 2, 2, 328, 325,
	3, 2, 2, 2, 328, 327, 3, 2, 2, 2, 329, 43, 3, 2, 2, 2, 330, 331, 7, 17,
	2, 2, 331, 332, 7, 84, 2, 2, 332, 333, 7, 5, 2, 2, 333, 334, 5, 46, 24,
	2, 334, 335, 7, 6, 2, 2, 335, 336, 7, 7, 2, 2, 336, 45, 3, 2, 2, 2, 337,
	338, 7, 85, 2, 2, 338, 339, 5, 48, 25, 2, 339, 47, 3, 2, 2, 2, 340, 341,
	7, 18, 2, 2, 341, 344, 5, 50, 26, 2, 342, 344, 3, 2, 2, 2, 343, 340, 3,
	2, 2, 2, 343, 342, 3, 2, 2, 2, 344, 49, 3, 2, 2, 2, 345, 346, 7, 85, 2,
	2, 346, 349, 5, 48, 25, 2, 347, 349, 3, 2, 2, 2, 348, 345, 3, 2, 2, 2,
	348, 347, 3, 2, 2, 2, 349, 51, 3, 2, 2, 2, 350, 351, 7, 84, 2, 2, 351,
	352, 7, 12, 2, 2, 352, 353, 5, 184, 93, 2, 353, 354, 7, 19, 2, 2, 354,
	355, 5, 112, 57, 2, 355, 356, 7, 20, 2, 2, 356, 357, 7, 7, 2, 2, 357, 53,
	3, 2, 2, 2, 358, 359, 7, 21, 2, 2, 359, 360, 5, 152, 77, 2, 360, 361, 7,
	84, 2, 2, 361, 362, 7, 7, 2, 2, 362, 55, 3, 2, 2, 2, 363, 364, 7, 84, 2,
	2, 364, 365, 7, 22, 2, 2, 365, 366, 7, 84, 2, 2, 366, 367, 7, 7, 2, 2,
	367, 57, 3, 2, 2, 2, 368, 369, 7, 23, 2, 2, 369, 370, 5, 166, 84, 2, 370,
	371, 7, 84, 2, 2, 371, 372, 7, 12, 2, 2, 372, 373, 5, 60, 31, 2, 373, 374,
	7, 7, 2, 2, 374, 59, 3, 2, 2, 2, 375, 380, 5, 62, 32, 2, 376, 380, 5, 64,
	33, 2, 377, 380, 7, 82, 2, 2, 378, 380, 7, 24, 2, 2, 379, 375, 3, 2, 2,
	2, 379, 376, 3, 2, 2, 2, 379, 377, 3, 2, 2, 2, 379, 378, 3, 2, 2, 2, 380,
	61, 3, 2, 2, 2, 381, 382, 9, 2, 2, 2, 382, 63, 3, 2, 2, 2, 383, 384, 9,
	3, 2, 2, 384, 65, 3, 2, 2, 2, 385, 386, 7, 30, 2, 2, 386, 387, 5, 68, 35,
	2, 387, 67, 3, 2, 2, 2, 388, 395, 5, 108, 55, 2, 389, 390, 7, 12, 2, 2,
	390, 391, 5, 70, 36, 2, 391, 392, 7, 7, 2, 2, 392, 395, 3, 2, 2, 2, 393,
	395, 7, 7, 2, 2, 394, 388, 3, 2, 2, 2, 394, 389, 3, 2, 2, 2, 394, 393,
	3, 2, 2, 2, 395, 69, 3, 2, 2, 2, 396, 397, 7, 5, 2, 2, 397, 398, 5, 72,
	37, 2, 398, 399, 7, 6, 2, 2, 399, 406, 3, 2, 2, 2, 400, 401, 7, 13, 2,
	2, 401, 402, 5, 74, 38, 2, 402, 403, 7, 14, 2, 2, 403, 406, 3, 2, 2, 2,
	404, 406, 7, 84, 2, 2, 405, 396, 3, 2, 2, 2, 405, 400, 3, 2, 2, 2, 405,
	404, 3, 2, 2, 2, 406, 71, 3, 2, 2, 2, 407, 414, 7, 31, 2, 2, 408, 409,
	7, 32, 2, 2, 409, 414, 5, 188, 95, 2, 410, 411, 7, 84, 2, 2, 411, 414,
	5, 188, 95, 2, 412, 414, 3, 2, 2, 2, 413, 407, 3, 2, 2, 2, 413, 408, 3,
	2, 2, 2, 413, 410, 3, 2, 2, 2, 413, 412, 3, 2, 2, 2, 414, 73, 3, 2, 2,
	2, 415, 420, 7, 31, 2, 2, 416, 417, 7, 84, 2, 2, 417, 420, 5, 188, 95,
	2, 418, 420, 3, 2, 2, 2, 419, 415, 3, 2, 2, 2, 419, 416, 3, 2, 2, 2, 419,
	418, 3, 2, 2, 2, 420, 75, 3, 2, 2, 2, 421, 422, 7, 33, 2, 2, 422, 423,
	5, 78, 40, 2, 423, 77, 3, 2, 2, 2, 424, 425, 5, 98, 50, 2, 425, 426, 5,
	90, 46, 2, 426, 432, 3, 2, 2, 2, 427, 428, 5, 184, 93, 2, 428, 429, 5,
	108, 55, 2, 429, 432, 3, 2, 2, 2, 430, 432, 7, 7, 2, 2, 431, 424, 3, 2,
	2, 2, 431, 427, 3, 2, 2, 2, 431, 430, 3, 2, 2, 2, 432, 79, 3, 2, 2, 2,
	433, 434, 7, 34, 2, 2, 434, 435, 5, 82, 42, 2, 435, 81, 3, 2, 2, 2, 436,
	437, 5, 98, 50, 2, 437, 438, 5, 90, 46, 2, 438, 443, 3, 2, 2, 2, 439, 440,
	5, 184, 93, 2, 440, 441, 5, 108, 55, 2, 441, 443, 3, 2, 2, 2, 442, 436,
	3, 2, 2, 2, 442, 439, 3, 2, 2, 2, 443, 83, 3, 2, 2, 2, 444, 445, 7, 35,
	2, 2, 445, 446, 5, 86, 44, 2, 446, 85, 3, 2, 2, 2, 447, 451, 5, 90, 46,
	2, 448, 451, 5, 128, 65, 2, 449, 451, 5, 130, 66, 2, 450, 447, 3, 2, 2,
	2, 450, 448, 3, 2, 2, 2, 450, 449, 3, 2, 2, 2, 451, 87, 3, 2, 2, 2, 452,
	453, 7, 32, 2, 2, 453, 454, 5, 98, 50, 2, 454, 455, 5, 90, 46, 2, 455,
	458, 3, 2, 2, 2, 456, 458, 5, 90, 46, 2, 457, 452, 3, 2, 2, 2, 457, 456,
	3, 2, 2, 2, 458, 89, 3, 2, 2, 2, 459, 460, 7, 36, 2, 2, 460, 461, 5, 152,
	77, 2, 461, 462, 5, 92, 47, 2, 462, 463, 7, 7, 2, 2, 463, 91, 3, 2, 2,
	2, 464, 467, 5, 94, 48, 2, 465, 467, 7, 84, 2, 2, 466, 464, 3, 2, 2, 2,
	466, 465, 3, 2, 2, 2, 467, 93, 3, 2, 2, 2, 468, 469, 7, 11, 2, 2, 469,
	95, 3, 2, 2, 2, 470, 473, 7, 32, 2, 2, 471, 473, 3, 2, 2, 2, 472, 470,
	3, 2, 2, 2, 472, 471, 3, 2, 2, 2, 473, 97, 3, 2, 2, 2, 474, 477, 7, 35,
	2, 2, 475, 477, 3, 2, 2, 2, 476, 474, 3, 2, 2, 2, 476, 475, 3, 2, 2, 2,
	477, 99, 3, 2, 2, 2, 478, 479, 5, 184, 93, 2, 479, 480, 5, 108, 55, 2,
	480, 483, 3, 2, 2, 2, 481, 483, 5, 102, 52, 2, 482, 478, 3, 2, 2, 2, 482,
	481, 3, 2, 2, 2, 483, 101, 3, 2, 2, 2, 484, 485, 5, 106, 54, 2, 485, 486,
	5, 104, 53, 2, 486, 487, 5, 184, 93, 2, 487, 488, 5, 108, 55, 2, 488, 103,
	3, 2, 2, 2, 489, 490, 5, 106, 54, 2, 490, 491, 5, 104, 53, 2, 491, 494,
	3, 2, 2, 2, 492, 494, 3, 2, 2, 2, 493, 489, 3, 2, 2, 2, 493, 492, 3, 2,
	2, 2, 494, 105, 3, 2, 2, 2, 495, 496, 9, 4, 2, 2, 496, 107, 3, 2, 2, 2,
	497, 498, 5, 110, 56, 2, 498, 499, 7, 19, 2, 2, 499, 500, 5, 112, 57, 2,
	500, 501, 7, 20, 2, 2, 501, 502, 7, 7, 2, 2, 502, 109, 3, 2, 2, 2, 503,
	506, 7, 84, 2, 2, 504, 506, 3, 2, 2, 2, 505, 503, 3, 2, 2, 2, 505, 504,
	3, 2, 2, 2, 506, 111, 3, 2, 2, 2, 507, 508, 5, 116, 59, 2, 508, 509, 5,
	114, 58, 2, 509, 512, 3, 2, 2, 2, 510, 512, 3, 2, 2, 2, 511, 507, 3, 2,
	2, 2, 511, 510, 3, 2, 2, 2, 512, 113, 3, 2, 2, 2, 513, 514, 7, 18, 2, 2,
	514, 515, 5, 116, 59, 2, 515, 516, 5, 114, 58, 2, 516, 519, 3, 2, 2, 2,
	517, 519, 3, 2, 2, 2, 518, 513, 3, 2, 2, 2, 518, 517, 3, 2, 2, 2, 519,
	115, 3, 2, 2, 2, 520, 521, 5, 136, 69, 2, 521, 522, 5, 118, 60, 2, 522,
	117, 3, 2, 2, 2, 523, 524, 7, 40, 2, 2, 524, 525, 5, 152, 77, 2, 525, 526,
	5, 120, 61, 2, 526, 527, 5, 36, 19, 2, 527, 533, 3, 2, 2, 2, 528, 529,
	5, 152, 77, 2, 529, 530, 5, 122, 62, 2, 530, 531, 5, 120, 61, 2, 531, 533,
	3, 2, 2, 2, 532, 523, 3, 2, 2, 2, 532, 528, 3, 2, 2, 2, 533, 119, 3, 2,
	2, 2, 534, 537, 5, 148, 75, 2, 535, 537, 7, 84, 2, 2, 536, 534, 3, 2, 2,
	2, 536, 535, 3, 2, 2, 2, 537, 121, 3, 2, 2, 2, 538, 541, 7, 41, 2, 2, 539,
	541, 3, 2, 2, 2, 540, 538, 3, 2, 2, 2, 540, 539, 3, 2, 2, 2, 541, 123,
	3, 2, 2, 2, 542, 543, 7, 42, 2, 2, 543, 544, 7, 43, 2, 2, 544, 545, 5,
	152, 77, 2, 545, 546, 5, 126, 64, 2, 546, 547, 7, 44, 2, 2, 547, 548, 7,
	7, 2, 2, 548, 125, 3, 2, 2, 2, 549, 550, 7, 18, 2, 2, 550, 553, 5, 152,
	77, 2, 551, 553, 3, 2, 2, 2, 552, 549, 3, 2, 2, 2, 552, 551, 3, 2, 2, 2,
	553, 127, 3, 2, 2, 2, 554, 555, 5, 132, 67, 2, 555, 129, 3, 2, 2, 2, 556,
	557, 5, 134, 68, 2, 557, 131, 3, 2, 2, 2, 558, 559, 7, 45, 2, 2, 559, 560,
	7, 43, 2, 2, 560, 561, 5, 152, 77, 2, 561, 562, 7, 18, 2, 2, 562, 563,
	5, 152, 77, 2, 563, 564, 7, 44, 2, 2, 564, 565, 7, 7, 2, 2, 565, 133, 3,
	2, 2, 2, 566, 567, 7, 46, 2, 2, 567, 568, 7, 43, 2, 2, 568, 569, 5, 152,
	77, 2, 569, 570, 7, 44, 2, 2, 570, 571, 7, 7, 2, 2, 571, 135, 3, 2, 2,
	2, 572, 573, 7, 13, 2, 2, 573, 574, 5, 140, 71, 2, 574, 575, 5, 138, 70,
	2, 575, 576, 7, 14, 2, 2, 576, 579, 3, 2, 2, 2, 577, 579, 3, 2, 2, 2, 578,
	572, 3, 2, 2, 2, 578, 577, 3, 2, 2, 2, 579, 137, 3, 2, 2, 2, 580, 581,
	7, 18, 2, 2, 581, 582, 5, 140, 71, 2, 582, 583, 5, 138, 70, 2, 583, 586,
	3, 2, 2, 2, 584, 586, 3, 2, 2, 2, 585, 580, 3, 2, 2, 2, 585, 584, 3, 2,
	2, 2, 586, 139, 3, 2, 2, 2, 587, 588, 7, 19, 2, 2, 588, 589, 5, 144, 73,
	2, 589, 590, 7, 20, 2, 2, 590, 591, 5, 142, 72, 2, 591, 606, 3, 2, 2, 2,
	592, 593, 7, 13, 2, 2, 593, 594, 5, 144, 73, 2, 594, 595, 7, 14, 2, 2,
	595, 596, 5, 142, 72, 2, 596, 606, 3, 2, 2, 2, 597, 598, 7, 5, 2, 2, 598,
	599, 5, 144, 73, 2, 599, 600, 7, 6, 2, 2, 600, 601, 5, 142, 72, 2, 601,
	606, 3, 2, 2, 2, 602, 603, 5, 146, 74, 2, 603, 604, 5, 142, 72, 2, 604,
	606, 3, 2, 2, 2, 605, 587, 3, 2, 2, 2, 605, 592, 3, 2, 2, 2, 605, 597,
	3, 2, 2, 2, 605, 602, 3, 2, 2, 2, 606, 141, 3, 2, 2, 2, 607, 610, 5, 140,
	71, 2, 608, 610, 3, 2, 2, 2, 609, 607, 3, 2, 2, 2, 609, 608, 3, 2, 2, 2,
	610, 143, 3, 2, 2, 2, 611, 612, 7, 19, 2, 2, 612, 613, 5, 144, 73, 2, 613,
	614, 7, 20, 2, 2, 614, 615, 5, 144, 73, 2, 615, 631, 3, 2, 2, 2, 616, 617,
	7, 13, 2, 2, 617, 618, 5, 144, 73, 2, 618, 619, 7, 14, 2, 2, 619, 620,
	5, 144, 73, 2, 620, 631, 3, 2, 2, 2, 621, 622, 7, 5, 2, 2, 622, 623, 5,
	144, 73, 2, 623, 624, 7, 6, 2, 2, 624, 625, 5, 144, 73, 2, 625, 631, 3,
	2, 2, 2, 626, 627, 5, 150, 76, 2, 627, 628, 5, 144, 73, 2, 628, 631, 3,
	2, 2, 2, 629, 631, 3, 2, 2, 2, 630, 611, 3, 2, 2, 2, 630, 616, 3, 2, 2,
	2, 630, 621, 3, 2, 2, 2, 630, 626, 3, 2, 2, 2, 630, 629, 3, 2, 2, 2, 631,
	145, 3, 2, 2, 2, 632, 674, 7, 82, 2, 2, 633, 674, 7, 83, 2, 2, 634, 674,
	7, 84, 2, 2, 635, 674, 7, 85, 2, 2, 636, 674, 7, 88, 2, 2, 637, 674, 7,
	47, 2, 2, 638, 674, 7, 27, 2, 2, 639, 674, 7, 48, 2, 2, 640, 674, 7, 41,
	2, 2, 641, 674, 7, 15, 2, 2, 642, 674, 7, 7, 2, 2, 643, 674, 7, 43, 2,
	2, 644, 674, 7, 12, 2, 2, 645, 674, 7, 44, 2, 2, 646, 674, 7, 49, 2, 2,
	647, 674, 7, 50, 2, 2, 648, 674, 7, 51, 2, 2, 649, 674, 7, 52, 2, 2, 650,
	674, 7, 28, 2, 2, 651, 674, 7, 29, 2, 2, 652, 674, 7, 53, 2, 2, 653, 674,
	7, 54, 2, 2, 654, 674, 7, 55, 2, 2, 655, 674, 7, 56, 2, 2, 656, 674, 7,
	57, 2, 2, 657, 674, 7, 58, 2, 2, 658, 674, 7, 26, 2, 2, 659, 674, 7, 59,
	2, 2, 660, 674, 7, 60, 2, 2, 661, 674, 7, 24, 2, 2, 662, 674, 7, 61, 2,
	2, 663, 674, 7, 62, 2, 2, 664, 674, 7, 63, 2, 2, 665, 674, 7, 40, 2, 2,
	666, 674, 7, 64, 2, 2, 667, 674, 7, 65, 2, 2, 668, 674, 7, 25, 2, 2, 669,
	674, 7, 66, 2, 2, 670, 674, 7, 67, 2, 2, 671, 674, 5, 148, 75, 2, 672,
	674, 5, 164, 83, 2, 673, 632, 3, 2, 2, 2, 673, 633, 3, 2, 2, 2, 673, 634,
	3, 2, 2, 2, 673, 635, 3, 2, 2, 2, 673, 636, 3, 2, 2, 2, 673, 637, 3, 2,
	2, 2, 673, 638, 3, 2, 2, 2, 673, 639, 3, 2, 2, 2, 673, 640, 3, 2, 2, 2,
	673, 641, 3, 2, 2, 2, 673, 642, 3, 2, 2, 2, 673, 643, 3, 2, 2, 2, 673,
	644, 3, 2, 2, 2, 673, 645, 3, 2, 2, 2, 673, 646, 3, 2, 2, 2, 673, 647,
	3, 2, 2, 2, 673, 648, 3, 2, 2, 2, 673, 649, 3, 2, 2, 2, 673, 650, 3, 2,
	2, 2, 673, 651, 3, 2, 2, 2, 673, 652, 3, 2, 2, 2, 673, 653, 3, 2, 2, 2,
	673, 654, 3, 2, 2, 2, 673, 655, 3, 2, 2, 2, 673, 656, 3, 2, 2, 2, 673,
	657, 3, 2, 2, 2, 673, 658, 3, 2, 2, 2, 673, 659, 3, 2, 2, 2, 673, 660,
	3, 2, 2, 2, 673, 661, 3, 2, 2, 2, 673, 662, 3, 2, 2, 2, 673, 663, 3, 2,
	2, 2, 673, 664, 3, 2, 2, 2, 673, 665, 3, 2, 2, 2, 673, 666, 3, 2, 2, 2,
	673, 667, 3, 2, 2, 2, 673, 668, 3, 2, 2, 2, 673, 669, 3, 2, 2, 2, 673,
	670, 3, 2, 2, 2, 673, 671, 3, 2, 2, 2, 673, 672, 3, 2, 2, 2, 674, 147,
	3, 2, 2, 2, 675, 676, 9, 5, 2, 2, 676, 149, 3, 2, 2, 2, 677, 680, 5, 146,
	74, 2, 678, 680, 7, 18, 2, 2, 679, 677, 3, 2, 2, 2, 679, 678, 3, 2, 2,
	2, 680, 151, 3, 2, 2, 2, 681, 686, 5, 154, 78, 2, 682, 683, 5, 156, 79,
	2, 683, 684, 5, 182, 92, 2, 684, 686, 3, 2, 2, 2, 685, 681, 3, 2, 2, 2,
	685, 682, 3, 2, 2, 2, 686, 153, 3, 2, 2, 2, 687, 690, 5, 162, 82, 2, 688,
	690, 7, 55, 2, 2, 689, 687, 3, 2, 2, 2, 689, 688, 3, 2, 2, 2, 690, 155,
	3, 2, 2, 2, 691, 692, 7, 19, 2, 2, 692, 693, 5, 158, 80, 2, 693, 694, 7,
	63, 2, 2, 694, 695, 5, 158, 80, 2, 695, 696, 5, 160, 81, 2, 696, 697, 7,
	20, 2, 2, 697, 157, 3, 2, 2, 2, 698, 703, 5, 162, 82, 2, 699, 700, 5, 156,
	79, 2, 700, 701, 5, 182, 92, 2, 701, 703, 3, 2, 2, 2, 702, 698, 3, 2, 2,
	2, 702, 699, 3, 2, 2, 2, 703, 159, 3, 2, 2, 2, 704, 705, 7, 63, 2, 2, 705,
	706, 5, 158, 80, 2, 706, 707, 5, 160, 81, 2, 707, 710, 3, 2, 2, 2, 708,
	710, 3, 2, 2, 2, 709, 704, 3, 2, 2, 2, 709, 708, 3, 2, 2, 2, 710, 161,
	3, 2, 2, 2, 711, 712, 5, 168, 85, 2, 712, 713, 5, 182, 92, 2, 713, 747,
	3, 2, 2, 2, 714, 715, 5, 180, 91, 2, 715, 716, 5, 182, 92, 2, 716, 747,
	3, 2, 2, 2, 717, 718, 7, 50, 2, 2, 718, 747, 5, 182, 92, 2, 719, 720, 7,
	51, 2, 2, 720, 747, 5, 182, 92, 2, 721, 722, 7, 54, 2, 2, 722, 747, 5,
	182, 92, 2, 723, 724, 7, 84, 2, 2, 724, 747, 5, 182, 92, 2, 725, 726, 7,
	64, 2, 2, 726, 727, 7, 43, 2, 2, 727, 728, 5, 152, 77, 2, 728, 729, 7,
	44, 2, 2, 729, 730, 5, 182, 92, 2, 730, 747, 3, 2, 2, 2, 731, 732, 7, 61,
	2, 2, 732, 747, 5, 182, 92, 2, 733, 734, 7, 53, 2, 2, 734, 747, 5, 182,
	92, 2, 735, 736, 7, 69, 2, 2, 736, 747, 5, 182, 92, 2, 737, 738, 5, 164,
	83, 2, 738, 739, 5, 182, 92, 2, 739, 747, 3, 2, 2, 2, 740, 741, 7, 52,
	2, 2, 741, 742, 7, 43, 2, 2, 742, 743, 5, 152, 77, 2, 743, 744, 7, 44,
	2, 2, 744, 745, 5, 182, 92, 2, 745, 747, 3, 2, 2, 2, 746, 711, 3, 2, 2,
	2, 746, 714, 3, 2, 2, 2, 746, 717, 3, 2, 2, 2, 746, 719, 3, 2, 2, 2, 746,
	721, 3, 2, 2, 2, 746, 723, 3, 2, 2, 2, 746, 725, 3, 2, 2, 2, 746, 731,
	3, 2, 2, 2, 746, 733, 3, 2, 2, 2, 746, 735, 3, 2, 2, 2, 746, 737, 3, 2,
	2, 2, 746, 740, 3, 2, 2, 2, 747, 163, 3, 2, 2, 2, 748, 749, 9, 6, 2, 2,
	749, 165, 3, 2, 2, 2, 750, 751, 5, 168, 85, 2, 751, 752, 5, 182, 92, 2,
	752, 756, 3, 2, 2, 2, 753, 754, 7, 84, 2, 2, 754, 756, 5, 182, 92, 2, 755,
	750, 3, 2, 2, 2, 755, 753, 3, 2, 2, 2, 756, 167, 3, 2, 2, 2, 757, 763,
	5, 174, 88, 2, 758, 763, 5, 170, 86, 2, 759, 763, 7, 56, 2, 2, 760, 763,
	7, 57, 2, 2, 761, 763, 7, 62, 2, 2, 762, 757, 3, 2, 2, 2, 762, 758, 3,
	2, 2, 2, 762, 759, 3, 2, 2, 2, 762, 760, 3, 2, 2, 2, 762, 761, 3, 2, 2,
	2, 763, 169, 3, 2, 2, 2, 764, 765, 7, 68, 2, 2, 765, 768, 5, 172, 87, 2,
	766, 768, 5, 172, 87, 2, 767, 764, 3, 2, 2, 2, 767, 766, 3, 2, 2, 2, 768,
	171, 3, 2, 2, 2, 769, 770, 9, 7, 2, 2, 770, 173, 3, 2, 2, 2, 771, 772,
	7, 66, 2, 2, 772, 775, 5, 176, 89, 2, 773, 775, 5, 176, 89, 2, 774, 771,
	3, 2, 2, 2, 774, 773, 3, 2, 2, 2, 775, 175, 3, 2, 2, 2, 776, 780, 7, 65,
	2, 2, 777, 778, 7, 60, 2, 2, 778, 780, 5, 178, 90, 2, 779, 776, 3, 2, 2,
	2, 779, 777, 3, 2, 2, 2, 780, 177, 3, 2, 2, 2, 781, 784, 7, 60, 2, 2, 782,
	784, 3, 2, 2, 2, 783, 781, 3, 2, 2, 2, 783, 782, 3, 2, 2, 2, 784, 179,
	3, 2, 2, 2, 785, 786, 7, 81, 2, 2, 786, 787, 7, 43, 2, 2, 787, 788, 5,
	184, 93, 2, 788, 789, 7, 44, 2, 2, 789, 181, 3, 2, 2, 2, 790, 793, 7, 49,
	2, 2, 791, 793, 3, 2, 2, 2, 792, 790, 3, 2, 2, 2, 792, 791, 3, 2, 2, 2,
	793, 183, 3, 2, 2, 2, 794, 797, 5, 152, 77, 2, 795, 797, 7, 67, 2, 2, 796,
	794, 3, 2, 2, 2, 796, 795, 3, 2, 2, 2, 797, 185, 3, 2, 2, 2, 798, 799,
	7, 84, 2, 2, 799, 800, 5, 188, 95, 2, 800, 187, 3, 2, 2, 2, 801, 802, 7,
	18, 2, 2, 802, 803, 7, 84, 2, 2, 803, 806, 5, 188, 95, 2, 804, 806, 3,
	2, 2, 2, 805, 801, 3, 2, 2, 2, 805, 804, 3, 2, 2, 2, 806, 189, 3, 2, 2,
	2, 807, 808, 7, 84, 2, 2, 808, 191, 3, 2, 2, 2, 809, 810, 7, 84, 2, 2,
	810, 811, 7, 19, 2, 2, 811, 812, 5, 112, 57, 2, 812, 813, 7, 20, 2, 2,
	813, 193, 3, 2, 2, 2, 814, 815, 7, 84, 2, 2, 815, 816, 7, 12, 2, 2, 816,
	817, 7, 84, 2, 2, 817, 195, 3, 2, 2, 2, 818, 819, 7, 84, 2, 2, 819, 820,
	7, 12, 2, 2, 820, 821, 7, 19, 2, 2, 821, 822, 5, 186, 94, 2, 822, 823,
	7, 20, 2, 2, 823, 197, 3, 2, 2, 2, 824, 825, 7, 84, 2, 2, 825, 826, 7,
	12, 2, 2, 826, 827, 7, 84, 2, 2, 827, 828, 7, 19, 2, 2, 828, 829, 5, 112,
	57, 2, 829, 830, 7, 20, 2, 2, 830, 199, 3, 2, 2, 2, 59, 208, 216, 222,
	226, 249, 263, 275, 290, 300, 312, 318, 323, 328, 343, 348, 379, 394, 405,
	413, 419, 431, 442, 450, 457, 466, 472, 476, 482, 493, 505, 511, 518, 532,
	536, 540, 552, 578, 585, 605, 609, 630, 673, 679, 685, 689, 702, 709, 746,
	755, 762, 767, 774, 779, 783, 792, 796, 805,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'callback'", "'interface'", "'{'", "'}'", "';'", "'class'", "'partial'",
	"'dictionary'", "'required'", "'='", "'['", "']'", "':'", "'extends'",
	"'enum'", "','", "'('", "')'", "'typedef'", "'implements'", "'const'",
	"'null'", "'true'", "'false'", "'-Infinity'", "'Infinity'", "'NaN'", "'serializer'",
	"'getter'", "'inherit'", "'stringifier'", "'static'", "'readonly'", "'attribute'",
	"'setter'", "'deleter'", "'legacycaller'", "'optional'", "'...'", "'iterable'",
	"'<'", "'>'", "'maplike'", "'setlike'", "'-'", "'.'", "'?'", "'ByteString'",
	"'DOMString'", "'FrozenArray'", "'RegExp'", "'USVString'", "'any'", "'boolean'",
	"'byte'", "'double'", "'float'", "'long'", "'object'", "'octet'", "'or'",
	"'sequence'", "'short'", "'unsigned'", "'void'", "'unrestricted'", "'DOMException'",
	"'ArrayBuffer'", "'DataView'", "'Int8Array'", "'Int16Array'", "'Int32Array'",
	"'Uint8Array'", "'Uint16Array'", "'Uint32Array'", "'Uint8ClampedArray'",
	"'Float32Array'", "'Float64Array'", "'Promise'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "INTEGER_WEBIDL", "FLOAT_WEBIDL", "IDENTIFIER_WEBIDL",
	"STRING_WEBIDL", "WHITESPACE_WEBIDL", "COMMENT_WEBIDL", "OTHER_WEBIDL",
}

var ruleNames = []string{
	"webIDL", "definitions", "definition", "callbackOrInterface", "callbackRestOrInterface",
	"interface_", "class_", "partial", "partialDefinition", "partialInterface",
	"interfaceMembers", "interfaceMember", "dictionary", "dictionaryMembers",
	"dictionaryMember", "required", "partialDictionary", "default_", "defaultValue",
	"inheritance", "extension", "enum_", "enumValueList", "enumValueListComma",
	"enumValueListString", "callbackRest", "typedef", "implementsStatement",
	"const_", "constValue", "booleanLiteral", "floatLiteral", "serializer",
	"serializerRest", "serializationPattern", "serializationPatternMap", "serializationPatternList",
	"stringifier", "stringifierRest", "staticMember", "staticMemberRest", "readonlyMember",
	"readonlyMemberRest", "readWriteAttribute", "attributeRest", "attributeName",
	"attributeNameKeyword", "inherit", "readOnly", "operation", "specialOperation",
	"specials", "special", "operationRest", "optionalIdentifier", "argumentList",
	"arguments", "argument", "optionalOrRequiredArgument", "argumentName",
	"ellipsis", "iterable", "optionalType", "readWriteMaplike", "readWriteSetlike",
	"maplikeRest", "setlikeRest", "extendedAttributeList", "extendedAttributes",
	"extendedAttribute", "extendedAttributeRest", "extendedAttributeInner",
	"other", "argumentNameKeyword", "otherOrComma", "type", "singleType", "unionType",
	"unionMemberType", "unionMemberTypes", "nonAnyType", "bufferRelatedType",
	"constType", "primitiveType", "unrestrictedFloatType", "floatType", "unsignedIntegerType",
	"integerType", "optionalLong", "promiseType", "null_", "returnType", "identifierList",
	"identifiers", "extendedAttributeNoArgs", "extendedAttributeArgList", "extendedAttributeIdent",
	"extendedAttributeIdentList", "extendedAttributeNamedArgList",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type WebIDLParser struct {
	*antlr.BaseParser
}

func NewWebIDLParser(input antlr.TokenStream) *WebIDLParser {
	this := new(WebIDLParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "WebIDL"

	return this
}

// WebIDLParser tokens.
const (
	WebIDLParserEOF               = antlr.TokenEOF
	WebIDLParserT__0              = 1
	WebIDLParserT__1              = 2
	WebIDLParserT__2              = 3
	WebIDLParserT__3              = 4
	WebIDLParserT__4              = 5
	WebIDLParserT__5              = 6
	WebIDLParserT__6              = 7
	WebIDLParserT__7              = 8
	WebIDLParserT__8              = 9
	WebIDLParserT__9              = 10
	WebIDLParserT__10             = 11
	WebIDLParserT__11             = 12
	WebIDLParserT__12             = 13
	WebIDLParserT__13             = 14
	WebIDLParserT__14             = 15
	WebIDLParserT__15             = 16
	WebIDLParserT__16             = 17
	WebIDLParserT__17             = 18
	WebIDLParserT__18             = 19
	WebIDLParserT__19             = 20
	WebIDLParserT__20             = 21
	WebIDLParserT__21             = 22
	WebIDLParserT__22             = 23
	WebIDLParserT__23             = 24
	WebIDLParserT__24             = 25
	WebIDLParserT__25             = 26
	WebIDLParserT__26             = 27
	WebIDLParserT__27             = 28
	WebIDLParserT__28             = 29
	WebIDLParserT__29             = 30
	WebIDLParserT__30             = 31
	WebIDLParserT__31             = 32
	WebIDLParserT__32             = 33
	WebIDLParserT__33             = 34
	WebIDLParserT__34             = 35
	WebIDLParserT__35             = 36
	WebIDLParserT__36             = 37
	WebIDLParserT__37             = 38
	WebIDLParserT__38             = 39
	WebIDLParserT__39             = 40
	WebIDLParserT__40             = 41
	WebIDLParserT__41             = 42
	WebIDLParserT__42             = 43
	WebIDLParserT__43             = 44
	WebIDLParserT__44             = 45
	WebIDLParserT__45             = 46
	WebIDLParserT__46             = 47
	WebIDLParserT__47             = 48
	WebIDLParserT__48             = 49
	WebIDLParserT__49             = 50
	WebIDLParserT__50             = 51
	WebIDLParserT__51             = 52
	WebIDLParserT__52             = 53
	WebIDLParserT__53             = 54
	WebIDLParserT__54             = 55
	WebIDLParserT__55             = 56
	WebIDLParserT__56             = 57
	WebIDLParserT__57             = 58
	WebIDLParserT__58             = 59
	WebIDLParserT__59             = 60
	WebIDLParserT__60             = 61
	WebIDLParserT__61             = 62
	WebIDLParserT__62             = 63
	WebIDLParserT__63             = 64
	WebIDLParserT__64             = 65
	WebIDLParserT__65             = 66
	WebIDLParserT__66             = 67
	WebIDLParserT__67             = 68
	WebIDLParserT__68             = 69
	WebIDLParserT__69             = 70
	WebIDLParserT__70             = 71
	WebIDLParserT__71             = 72
	WebIDLParserT__72             = 73
	WebIDLParserT__73             = 74
	WebIDLParserT__74             = 75
	WebIDLParserT__75             = 76
	WebIDLParserT__76             = 77
	WebIDLParserT__77             = 78
	WebIDLParserT__78             = 79
	WebIDLParserINTEGER_WEBIDL    = 80
	WebIDLParserFLOAT_WEBIDL      = 81
	WebIDLParserIDENTIFIER_WEBIDL = 82
	WebIDLParserSTRING_WEBIDL     = 83
	WebIDLParserWHITESPACE_WEBIDL = 84
	WebIDLParserCOMMENT_WEBIDL    = 85
	WebIDLParserOTHER_WEBIDL      = 86
)

// WebIDLParser rules.
const (
	WebIDLParserRULE_webIDL                        = 0
	WebIDLParserRULE_definitions                   = 1
	WebIDLParserRULE_definition                    = 2
	WebIDLParserRULE_callbackOrInterface           = 3
	WebIDLParserRULE_callbackRestOrInterface       = 4
	WebIDLParserRULE_interface_                    = 5
	WebIDLParserRULE_class_                        = 6
	WebIDLParserRULE_partial                       = 7
	WebIDLParserRULE_partialDefinition             = 8
	WebIDLParserRULE_partialInterface              = 9
	WebIDLParserRULE_interfaceMembers              = 10
	WebIDLParserRULE_interfaceMember               = 11
	WebIDLParserRULE_dictionary                    = 12
	WebIDLParserRULE_dictionaryMembers             = 13
	WebIDLParserRULE_dictionaryMember              = 14
	WebIDLParserRULE_required                      = 15
	WebIDLParserRULE_partialDictionary             = 16
	WebIDLParserRULE_default_                      = 17
	WebIDLParserRULE_defaultValue                  = 18
	WebIDLParserRULE_inheritance                   = 19
	WebIDLParserRULE_extension                     = 20
	WebIDLParserRULE_enum_                         = 21
	WebIDLParserRULE_enumValueList                 = 22
	WebIDLParserRULE_enumValueListComma            = 23
	WebIDLParserRULE_enumValueListString           = 24
	WebIDLParserRULE_callbackRest                  = 25
	WebIDLParserRULE_typedef                       = 26
	WebIDLParserRULE_implementsStatement           = 27
	WebIDLParserRULE_const_                        = 28
	WebIDLParserRULE_constValue                    = 29
	WebIDLParserRULE_booleanLiteral                = 30
	WebIDLParserRULE_floatLiteral                  = 31
	WebIDLParserRULE_serializer                    = 32
	WebIDLParserRULE_serializerRest                = 33
	WebIDLParserRULE_serializationPattern          = 34
	WebIDLParserRULE_serializationPatternMap       = 35
	WebIDLParserRULE_serializationPatternList      = 36
	WebIDLParserRULE_stringifier                   = 37
	WebIDLParserRULE_stringifierRest               = 38
	WebIDLParserRULE_staticMember                  = 39
	WebIDLParserRULE_staticMemberRest              = 40
	WebIDLParserRULE_readonlyMember                = 41
	WebIDLParserRULE_readonlyMemberRest            = 42
	WebIDLParserRULE_readWriteAttribute            = 43
	WebIDLParserRULE_attributeRest                 = 44
	WebIDLParserRULE_attributeName                 = 45
	WebIDLParserRULE_attributeNameKeyword          = 46
	WebIDLParserRULE_inherit                       = 47
	WebIDLParserRULE_readOnly                      = 48
	WebIDLParserRULE_operation                     = 49
	WebIDLParserRULE_specialOperation              = 50
	WebIDLParserRULE_specials                      = 51
	WebIDLParserRULE_special                       = 52
	WebIDLParserRULE_operationRest                 = 53
	WebIDLParserRULE_optionalIdentifier            = 54
	WebIDLParserRULE_argumentList                  = 55
	WebIDLParserRULE_arguments                     = 56
	WebIDLParserRULE_argument                      = 57
	WebIDLParserRULE_optionalOrRequiredArgument    = 58
	WebIDLParserRULE_argumentName                  = 59
	WebIDLParserRULE_ellipsis                      = 60
	WebIDLParserRULE_iterable                      = 61
	WebIDLParserRULE_optionalType                  = 62
	WebIDLParserRULE_readWriteMaplike              = 63
	WebIDLParserRULE_readWriteSetlike              = 64
	WebIDLParserRULE_maplikeRest                   = 65
	WebIDLParserRULE_setlikeRest                   = 66
	WebIDLParserRULE_extendedAttributeList         = 67
	WebIDLParserRULE_extendedAttributes            = 68
	WebIDLParserRULE_extendedAttribute             = 69
	WebIDLParserRULE_extendedAttributeRest         = 70
	WebIDLParserRULE_extendedAttributeInner        = 71
	WebIDLParserRULE_other                         = 72
	WebIDLParserRULE_argumentNameKeyword           = 73
	WebIDLParserRULE_otherOrComma                  = 74
	WebIDLParserRULE_type                          = 75
	WebIDLParserRULE_singleType                    = 76
	WebIDLParserRULE_unionType                     = 77
	WebIDLParserRULE_unionMemberType               = 78
	WebIDLParserRULE_unionMemberTypes              = 79
	WebIDLParserRULE_nonAnyType                    = 80
	WebIDLParserRULE_bufferRelatedType             = 81
	WebIDLParserRULE_constType                     = 82
	WebIDLParserRULE_primitiveType                 = 83
	WebIDLParserRULE_unrestrictedFloatType         = 84
	WebIDLParserRULE_floatType                     = 85
	WebIDLParserRULE_unsignedIntegerType           = 86
	WebIDLParserRULE_integerType                   = 87
	WebIDLParserRULE_optionalLong                  = 88
	WebIDLParserRULE_promiseType                   = 89
	WebIDLParserRULE_null_                         = 90
	WebIDLParserRULE_returnType                    = 91
	WebIDLParserRULE_identifierList                = 92
	WebIDLParserRULE_identifiers                   = 93
	WebIDLParserRULE_extendedAttributeNoArgs       = 94
	WebIDLParserRULE_extendedAttributeArgList      = 95
	WebIDLParserRULE_extendedAttributeIdent        = 96
	WebIDLParserRULE_extendedAttributeIdentList    = 97
	WebIDLParserRULE_extendedAttributeNamedArgList = 98
)

// IWebIDLContext is an interface to support dynamic dispatch.
type IWebIDLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWebIDLContext differentiates from other interfaces.
	IsWebIDLContext()
}

type WebIDLContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWebIDLContext() *WebIDLContext {
	var p = new(WebIDLContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_webIDL
	return p
}

func (*WebIDLContext) IsWebIDLContext() {}

func NewWebIDLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WebIDLContext {
	var p = new(WebIDLContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_webIDL

	return p
}

func (s *WebIDLContext) GetParser() antlr.Parser { return s.parser }

func (s *WebIDLContext) Definitions() IDefinitionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinitionsContext)
}

func (s *WebIDLContext) EOF() antlr.TerminalNode {
	return s.GetToken(WebIDLParserEOF, 0)
}

func (s *WebIDLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WebIDLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WebIDLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterWebIDL(s)
	}
}

func (s *WebIDLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitWebIDL(s)
	}
}

func (p *WebIDLParser) WebIDL() (localctx IWebIDLContext) {
	localctx = NewWebIDLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, WebIDLParserRULE_webIDL)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(198)
		p.Definitions()
	}
	{
		p.SetState(199)
		p.Match(WebIDLParserEOF)
	}

	return localctx
}

// IDefinitionsContext is an interface to support dynamic dispatch.
type IDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinitionsContext differentiates from other interfaces.
	IsDefinitionsContext()
}

type DefinitionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionsContext() *DefinitionsContext {
	var p = new(DefinitionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_definitions
	return p
}

func (*DefinitionsContext) IsDefinitionsContext() {}

func NewDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionsContext {
	var p = new(DefinitionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_definitions

	return p
}

func (s *DefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionsContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *DefinitionsContext) Definition() IDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinitionContext)
}

func (s *DefinitionsContext) Definitions() IDefinitionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefinitionsContext)
}

func (s *DefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDefinitions(s)
	}
}

func (s *DefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDefinitions(s)
	}
}

func (p *WebIDLParser) Definitions() (localctx IDefinitionsContext) {
	localctx = NewDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, WebIDLParserRULE_definitions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(206)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__10, WebIDLParserT__14, WebIDLParserT__18, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(201)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(202)
			p.Definition()
		}
		{
			p.SetState(203)
			p.Definitions()
		}

	case WebIDLParserEOF:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefinitionContext is an interface to support dynamic dispatch.
type IDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinitionContext differentiates from other interfaces.
	IsDefinitionContext()
}

type DefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionContext() *DefinitionContext {
	var p = new(DefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_definition
	return p
}

func (*DefinitionContext) IsDefinitionContext() {}

func NewDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionContext {
	var p = new(DefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_definition

	return p
}

func (s *DefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionContext) CallbackOrInterface() ICallbackOrInterfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackOrInterfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackOrInterfaceContext)
}

func (s *DefinitionContext) Partial() IPartialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialContext)
}

func (s *DefinitionContext) Dictionary() IDictionaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryContext)
}

func (s *DefinitionContext) Enum_() IEnum_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_Context)
}

func (s *DefinitionContext) Typedef() ITypedefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypedefContext)
}

func (s *DefinitionContext) ImplementsStatement() IImplementsStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImplementsStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImplementsStatementContext)
}

func (s *DefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDefinition(s)
	}
}

func (s *DefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDefinition(s)
	}
}

func (p *WebIDLParser) Definition() (localctx IDefinitionContext) {
	localctx = NewDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, WebIDLParserRULE_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(214)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__5:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(208)
			p.CallbackOrInterface()
		}

	case WebIDLParserT__6:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(209)
			p.Partial()
		}

	case WebIDLParserT__7:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(210)
			p.Dictionary()
		}

	case WebIDLParserT__14:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(211)
			p.Enum_()
		}

	case WebIDLParserT__18:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(212)
			p.Typedef()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(213)
			p.ImplementsStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallbackOrInterfaceContext is an interface to support dynamic dispatch.
type ICallbackOrInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallbackOrInterfaceContext differentiates from other interfaces.
	IsCallbackOrInterfaceContext()
}

type CallbackOrInterfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallbackOrInterfaceContext() *CallbackOrInterfaceContext {
	var p = new(CallbackOrInterfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_callbackOrInterface
	return p
}

func (*CallbackOrInterfaceContext) IsCallbackOrInterfaceContext() {}

func NewCallbackOrInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallbackOrInterfaceContext {
	var p = new(CallbackOrInterfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_callbackOrInterface

	return p
}

func (s *CallbackOrInterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallbackOrInterfaceContext) CallbackRestOrInterface() ICallbackRestOrInterfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackRestOrInterfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackRestOrInterfaceContext)
}

func (s *CallbackOrInterfaceContext) Interface_() IInterface_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_Context)
}

func (s *CallbackOrInterfaceContext) Class_() IClass_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClass_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClass_Context)
}

func (s *CallbackOrInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallbackOrInterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallbackOrInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterCallbackOrInterface(s)
	}
}

func (s *CallbackOrInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitCallbackOrInterface(s)
	}
}

func (p *WebIDLParser) CallbackOrInterface() (localctx ICallbackOrInterfaceContext) {
	localctx = NewCallbackOrInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, WebIDLParserRULE_callbackOrInterface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(220)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(216)
			p.Match(WebIDLParserT__0)
		}
		{
			p.SetState(217)
			p.CallbackRestOrInterface()
		}

	case WebIDLParserT__1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(218)
			p.Interface_()
		}

	case WebIDLParserT__5:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(219)
			p.Class_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallbackRestOrInterfaceContext is an interface to support dynamic dispatch.
type ICallbackRestOrInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallbackRestOrInterfaceContext differentiates from other interfaces.
	IsCallbackRestOrInterfaceContext()
}

type CallbackRestOrInterfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallbackRestOrInterfaceContext() *CallbackRestOrInterfaceContext {
	var p = new(CallbackRestOrInterfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_callbackRestOrInterface
	return p
}

func (*CallbackRestOrInterfaceContext) IsCallbackRestOrInterfaceContext() {}

func NewCallbackRestOrInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallbackRestOrInterfaceContext {
	var p = new(CallbackRestOrInterfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_callbackRestOrInterface

	return p
}

func (s *CallbackRestOrInterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallbackRestOrInterfaceContext) CallbackRest() ICallbackRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICallbackRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICallbackRestContext)
}

func (s *CallbackRestOrInterfaceContext) Interface_() IInterface_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_Context)
}

func (s *CallbackRestOrInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallbackRestOrInterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallbackRestOrInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterCallbackRestOrInterface(s)
	}
}

func (s *CallbackRestOrInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitCallbackRestOrInterface(s)
	}
}

func (p *WebIDLParser) CallbackRestOrInterface() (localctx ICallbackRestOrInterfaceContext) {
	localctx = NewCallbackRestOrInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, WebIDLParserRULE_callbackRestOrInterface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(224)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(222)
			p.CallbackRest()
		}

	case WebIDLParserT__1:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(223)
			p.Interface_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterface_Context is an interface to support dynamic dispatch.
type IInterface_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_Context differentiates from other interfaces.
	IsInterface_Context()
}

type Interface_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_Context() *Interface_Context {
	var p = new(Interface_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_interface_
	return p
}

func (*Interface_Context) IsInterface_Context() {}

func NewInterface_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_Context {
	var p = new(Interface_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_interface_

	return p
}

func (s *Interface_Context) GetParser() antlr.Parser { return s.parser }

func (s *Interface_Context) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *Interface_Context) Inheritance() IInheritanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInheritanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInheritanceContext)
}

func (s *Interface_Context) InterfaceMembers() IInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMembersContext)
}

func (s *Interface_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInterface_(s)
	}
}

func (s *Interface_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInterface_(s)
	}
}

func (p *WebIDLParser) Interface_() (localctx IInterface_Context) {
	localctx = NewInterface_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, WebIDLParserRULE_interface_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(226)
		p.Match(WebIDLParserT__1)
	}
	{
		p.SetState(227)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(228)
		p.Inheritance()
	}
	{
		p.SetState(229)
		p.Match(WebIDLParserT__2)
	}
	{
		p.SetState(230)
		p.InterfaceMembers()
	}
	{
		p.SetState(231)
		p.Match(WebIDLParserT__3)
	}
	{
		p.SetState(232)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IClass_Context is an interface to support dynamic dispatch.
type IClass_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClass_Context differentiates from other interfaces.
	IsClass_Context()
}

type Class_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClass_Context() *Class_Context {
	var p = new(Class_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_class_
	return p
}

func (*Class_Context) IsClass_Context() {}

func NewClass_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Class_Context {
	var p = new(Class_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_class_

	return p
}

func (s *Class_Context) GetParser() antlr.Parser { return s.parser }

func (s *Class_Context) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *Class_Context) Extension() IExtensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtensionContext)
}

func (s *Class_Context) InterfaceMembers() IInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMembersContext)
}

func (s *Class_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Class_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Class_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterClass_(s)
	}
}

func (s *Class_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitClass_(s)
	}
}

func (p *WebIDLParser) Class_() (localctx IClass_Context) {
	localctx = NewClass_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, WebIDLParserRULE_class_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(234)
		p.Match(WebIDLParserT__5)
	}
	{
		p.SetState(235)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(236)
		p.Extension()
	}
	{
		p.SetState(237)
		p.Match(WebIDLParserT__2)
	}
	{
		p.SetState(238)
		p.InterfaceMembers()
	}
	{
		p.SetState(239)
		p.Match(WebIDLParserT__3)
	}
	{
		p.SetState(240)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IPartialContext is an interface to support dynamic dispatch.
type IPartialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialContext differentiates from other interfaces.
	IsPartialContext()
}

type PartialContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialContext() *PartialContext {
	var p = new(PartialContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partial
	return p
}

func (*PartialContext) IsPartialContext() {}

func NewPartialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialContext {
	var p = new(PartialContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partial

	return p
}

func (s *PartialContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialContext) PartialDefinition() IPartialDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialDefinitionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialDefinitionContext)
}

func (s *PartialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartial(s)
	}
}

func (s *PartialContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartial(s)
	}
}

func (p *WebIDLParser) Partial() (localctx IPartialContext) {
	localctx = NewPartialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, WebIDLParserRULE_partial)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Match(WebIDLParserT__6)
	}
	{
		p.SetState(243)
		p.PartialDefinition()
	}

	return localctx
}

// IPartialDefinitionContext is an interface to support dynamic dispatch.
type IPartialDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialDefinitionContext differentiates from other interfaces.
	IsPartialDefinitionContext()
}

type PartialDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialDefinitionContext() *PartialDefinitionContext {
	var p = new(PartialDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialDefinition
	return p
}

func (*PartialDefinitionContext) IsPartialDefinitionContext() {}

func NewPartialDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialDefinitionContext {
	var p = new(PartialDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialDefinition

	return p
}

func (s *PartialDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialDefinitionContext) PartialInterface() IPartialInterfaceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialInterfaceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialInterfaceContext)
}

func (s *PartialDefinitionContext) PartialDictionary() IPartialDictionaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartialDictionaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartialDictionaryContext)
}

func (s *PartialDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialDefinition(s)
	}
}

func (s *PartialDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialDefinition(s)
	}
}

func (p *WebIDLParser) PartialDefinition() (localctx IPartialDefinitionContext) {
	localctx = NewPartialDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, WebIDLParserRULE_partialDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(247)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(245)
			p.PartialInterface()
		}

	case WebIDLParserT__7:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(246)
			p.PartialDictionary()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPartialInterfaceContext is an interface to support dynamic dispatch.
type IPartialInterfaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialInterfaceContext differentiates from other interfaces.
	IsPartialInterfaceContext()
}

type PartialInterfaceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialInterfaceContext() *PartialInterfaceContext {
	var p = new(PartialInterfaceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialInterface
	return p
}

func (*PartialInterfaceContext) IsPartialInterfaceContext() {}

func NewPartialInterfaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialInterfaceContext {
	var p = new(PartialInterfaceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialInterface

	return p
}

func (s *PartialInterfaceContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialInterfaceContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *PartialInterfaceContext) InterfaceMembers() IInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMembersContext)
}

func (s *PartialInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialInterfaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialInterface(s)
	}
}

func (s *PartialInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialInterface(s)
	}
}

func (p *WebIDLParser) PartialInterface() (localctx IPartialInterfaceContext) {
	localctx = NewPartialInterfaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, WebIDLParserRULE_partialInterface)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(249)
		p.Match(WebIDLParserT__1)
	}
	{
		p.SetState(250)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(251)
		p.Match(WebIDLParserT__2)
	}
	{
		p.SetState(252)
		p.InterfaceMembers()
	}
	{
		p.SetState(253)
		p.Match(WebIDLParserT__3)
	}
	{
		p.SetState(254)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IInterfaceMembersContext is an interface to support dynamic dispatch.
type IInterfaceMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMembersContext differentiates from other interfaces.
	IsInterfaceMembersContext()
}

type InterfaceMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMembersContext() *InterfaceMembersContext {
	var p = new(InterfaceMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_interfaceMembers
	return p
}

func (*InterfaceMembersContext) IsInterfaceMembersContext() {}

func NewInterfaceMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMembersContext {
	var p = new(InterfaceMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_interfaceMembers

	return p
}

func (s *InterfaceMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMembersContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *InterfaceMembersContext) InterfaceMember() IInterfaceMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMemberContext)
}

func (s *InterfaceMembersContext) InterfaceMembers() IInterfaceMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMembersContext)
}

func (s *InterfaceMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInterfaceMembers(s)
	}
}

func (s *InterfaceMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInterfaceMembers(s)
	}
}

func (p *WebIDLParser) InterfaceMembers() (localctx IInterfaceMembersContext) {
	localctx = NewInterfaceMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, WebIDLParserRULE_interfaceMembers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(261)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__10, WebIDLParserT__16, WebIDLParserT__20, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__32, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__39, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(256)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(257)
			p.InterfaceMember()
		}
		{
			p.SetState(258)
			p.InterfaceMembers()
		}

	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterfaceMemberContext is an interface to support dynamic dispatch.
type IInterfaceMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMemberContext differentiates from other interfaces.
	IsInterfaceMemberContext()
}

type InterfaceMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMemberContext() *InterfaceMemberContext {
	var p = new(InterfaceMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_interfaceMember
	return p
}

func (*InterfaceMemberContext) IsInterfaceMemberContext() {}

func NewInterfaceMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMemberContext {
	var p = new(InterfaceMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_interfaceMember

	return p
}

func (s *InterfaceMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMemberContext) Const_() IConst_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_Context)
}

func (s *InterfaceMemberContext) Operation() IOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationContext)
}

func (s *InterfaceMemberContext) Serializer() ISerializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISerializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISerializerContext)
}

func (s *InterfaceMemberContext) Stringifier() IStringifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringifierContext)
}

func (s *InterfaceMemberContext) StaticMember() IStaticMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticMemberContext)
}

func (s *InterfaceMemberContext) Iterable() IIterableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIterableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIterableContext)
}

func (s *InterfaceMemberContext) ReadonlyMember() IReadonlyMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadonlyMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadonlyMemberContext)
}

func (s *InterfaceMemberContext) ReadWriteAttribute() IReadWriteAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWriteAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWriteAttributeContext)
}

func (s *InterfaceMemberContext) ReadWriteMaplike() IReadWriteMaplikeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWriteMaplikeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWriteMaplikeContext)
}

func (s *InterfaceMemberContext) ReadWriteSetlike() IReadWriteSetlikeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWriteSetlikeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWriteSetlikeContext)
}

func (s *InterfaceMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInterfaceMember(s)
	}
}

func (s *InterfaceMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInterfaceMember(s)
	}
}

func (p *WebIDLParser) InterfaceMember() (localctx IInterfaceMemberContext) {
	localctx = NewInterfaceMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, WebIDLParserRULE_interfaceMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(273)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__20:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(263)
			p.Const_()
		}

	case WebIDLParserT__16, WebIDLParserT__28, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(264)
			p.Operation()
		}

	case WebIDLParserT__27:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(265)
			p.Serializer()
		}

	case WebIDLParserT__30:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(266)
			p.Stringifier()
		}

	case WebIDLParserT__31:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(267)
			p.StaticMember()
		}

	case WebIDLParserT__39:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(268)
			p.Iterable()
		}

	case WebIDLParserT__32:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(269)
			p.ReadonlyMember()
		}

	case WebIDLParserT__29, WebIDLParserT__33:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(270)
			p.ReadWriteAttribute()
		}

	case WebIDLParserT__42:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(271)
			p.ReadWriteMaplike()
		}

	case WebIDLParserT__43:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(272)
			p.ReadWriteSetlike()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDictionaryContext is an interface to support dynamic dispatch.
type IDictionaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryContext differentiates from other interfaces.
	IsDictionaryContext()
}

type DictionaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryContext() *DictionaryContext {
	var p = new(DictionaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_dictionary
	return p
}

func (*DictionaryContext) IsDictionaryContext() {}

func NewDictionaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryContext {
	var p = new(DictionaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_dictionary

	return p
}

func (s *DictionaryContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *DictionaryContext) Inheritance() IInheritanceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInheritanceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInheritanceContext)
}

func (s *DictionaryContext) DictionaryMembers() IDictionaryMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMembersContext)
}

func (s *DictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDictionary(s)
	}
}

func (s *DictionaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDictionary(s)
	}
}

func (p *WebIDLParser) Dictionary() (localctx IDictionaryContext) {
	localctx = NewDictionaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, WebIDLParserRULE_dictionary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(275)
		p.Match(WebIDLParserT__7)
	}
	{
		p.SetState(276)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(277)
		p.Inheritance()
	}
	{
		p.SetState(278)
		p.Match(WebIDLParserT__2)
	}
	{
		p.SetState(279)
		p.DictionaryMembers()
	}
	{
		p.SetState(280)
		p.Match(WebIDLParserT__3)
	}
	{
		p.SetState(281)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IDictionaryMembersContext is an interface to support dynamic dispatch.
type IDictionaryMembersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryMembersContext differentiates from other interfaces.
	IsDictionaryMembersContext()
}

type DictionaryMembersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryMembersContext() *DictionaryMembersContext {
	var p = new(DictionaryMembersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_dictionaryMembers
	return p
}

func (*DictionaryMembersContext) IsDictionaryMembersContext() {}

func NewDictionaryMembersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryMembersContext {
	var p = new(DictionaryMembersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_dictionaryMembers

	return p
}

func (s *DictionaryMembersContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryMembersContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *DictionaryMembersContext) DictionaryMember() IDictionaryMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMemberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMemberContext)
}

func (s *DictionaryMembersContext) DictionaryMembers() IDictionaryMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMembersContext)
}

func (s *DictionaryMembersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryMembersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryMembersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDictionaryMembers(s)
	}
}

func (s *DictionaryMembersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDictionaryMembers(s)
	}
}

func (p *WebIDLParser) DictionaryMembers() (localctx IDictionaryMembersContext) {
	localctx = NewDictionaryMembersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, WebIDLParserRULE_dictionaryMembers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(288)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__8, WebIDLParserT__10, WebIDLParserT__16, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(283)
			p.ExtendedAttributeList()
		}
		{
			p.SetState(284)
			p.DictionaryMember()
		}
		{
			p.SetState(285)
			p.DictionaryMembers()
		}

	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDictionaryMemberContext is an interface to support dynamic dispatch.
type IDictionaryMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDictionaryMemberContext differentiates from other interfaces.
	IsDictionaryMemberContext()
}

type DictionaryMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryMemberContext() *DictionaryMemberContext {
	var p = new(DictionaryMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_dictionaryMember
	return p
}

func (*DictionaryMemberContext) IsDictionaryMemberContext() {}

func NewDictionaryMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryMemberContext {
	var p = new(DictionaryMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_dictionaryMember

	return p
}

func (s *DictionaryMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryMemberContext) Required() IRequiredContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRequiredContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRequiredContext)
}

func (s *DictionaryMemberContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *DictionaryMemberContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *DictionaryMemberContext) Default_() IDefault_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_Context)
}

func (s *DictionaryMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDictionaryMember(s)
	}
}

func (s *DictionaryMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDictionaryMember(s)
	}
}

func (p *WebIDLParser) DictionaryMember() (localctx IDictionaryMemberContext) {
	localctx = NewDictionaryMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, WebIDLParserRULE_dictionaryMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(290)
		p.Required()
	}
	{
		p.SetState(291)
		p.Type()
	}
	{
		p.SetState(292)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(293)
		p.Default_()
	}
	{
		p.SetState(294)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IRequiredContext is an interface to support dynamic dispatch.
type IRequiredContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRequiredContext differentiates from other interfaces.
	IsRequiredContext()
}

type RequiredContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequiredContext() *RequiredContext {
	var p = new(RequiredContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_required
	return p
}

func (*RequiredContext) IsRequiredContext() {}

func NewRequiredContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequiredContext {
	var p = new(RequiredContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_required

	return p
}

func (s *RequiredContext) GetParser() antlr.Parser { return s.parser }
func (s *RequiredContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequiredContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequiredContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterRequired(s)
	}
}

func (s *RequiredContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitRequired(s)
	}
}

func (p *WebIDLParser) Required() (localctx IRequiredContext) {
	localctx = NewRequiredContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, WebIDLParserRULE_required)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(298)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(296)
			p.Match(WebIDLParserT__8)
		}

	case WebIDLParserT__16, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPartialDictionaryContext is an interface to support dynamic dispatch.
type IPartialDictionaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartialDictionaryContext differentiates from other interfaces.
	IsPartialDictionaryContext()
}

type PartialDictionaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartialDictionaryContext() *PartialDictionaryContext {
	var p = new(PartialDictionaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_partialDictionary
	return p
}

func (*PartialDictionaryContext) IsPartialDictionaryContext() {}

func NewPartialDictionaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartialDictionaryContext {
	var p = new(PartialDictionaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_partialDictionary

	return p
}

func (s *PartialDictionaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PartialDictionaryContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *PartialDictionaryContext) DictionaryMembers() IDictionaryMembersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDictionaryMembersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDictionaryMembersContext)
}

func (s *PartialDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartialDictionaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartialDictionaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPartialDictionary(s)
	}
}

func (s *PartialDictionaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPartialDictionary(s)
	}
}

func (p *WebIDLParser) PartialDictionary() (localctx IPartialDictionaryContext) {
	localctx = NewPartialDictionaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, WebIDLParserRULE_partialDictionary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(300)
		p.Match(WebIDLParserT__7)
	}
	{
		p.SetState(301)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(302)
		p.Match(WebIDLParserT__2)
	}
	{
		p.SetState(303)
		p.DictionaryMembers()
	}
	{
		p.SetState(304)
		p.Match(WebIDLParserT__3)
	}
	{
		p.SetState(305)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IDefault_Context is an interface to support dynamic dispatch.
type IDefault_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefault_Context differentiates from other interfaces.
	IsDefault_Context()
}

type Default_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefault_Context() *Default_Context {
	var p = new(Default_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_default_
	return p
}

func (*Default_Context) IsDefault_Context() {}

func NewDefault_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Default_Context {
	var p = new(Default_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_default_

	return p
}

func (s *Default_Context) GetParser() antlr.Parser { return s.parser }

func (s *Default_Context) DefaultValue() IDefaultValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefaultValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *Default_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Default_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Default_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDefault_(s)
	}
}

func (s *Default_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDefault_(s)
	}
}

func (p *WebIDLParser) Default_() (localctx IDefault_Context) {
	localctx = NewDefault_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, WebIDLParserRULE_default_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(310)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__9:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(307)
			p.Match(WebIDLParserT__9)
		}
		{
			p.SetState(308)
			p.DefaultValue()
		}

	case WebIDLParserT__4, WebIDLParserT__15, WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_defaultValue
	return p
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) ConstValue() IConstValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstValueContext)
}

func (s *DefaultValueContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *WebIDLParser) DefaultValue() (localctx IDefaultValueContext) {
	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, WebIDLParserRULE_defaultValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(316)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__25, WebIDLParserT__26, WebIDLParserINTEGER_WEBIDL, WebIDLParserFLOAT_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(312)
			p.ConstValue()
		}

	case WebIDLParserSTRING_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(313)
			p.Match(WebIDLParserSTRING_WEBIDL)
		}

	case WebIDLParserT__10:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(314)
			p.Match(WebIDLParserT__10)
		}
		{
			p.SetState(315)
			p.Match(WebIDLParserT__11)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInheritanceContext is an interface to support dynamic dispatch.
type IInheritanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInheritanceContext differentiates from other interfaces.
	IsInheritanceContext()
}

type InheritanceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritanceContext() *InheritanceContext {
	var p = new(InheritanceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_inheritance
	return p
}

func (*InheritanceContext) IsInheritanceContext() {}

func NewInheritanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritanceContext {
	var p = new(InheritanceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_inheritance

	return p
}

func (s *InheritanceContext) GetParser() antlr.Parser { return s.parser }

func (s *InheritanceContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *InheritanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInheritance(s)
	}
}

func (s *InheritanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInheritance(s)
	}
}

func (p *WebIDLParser) Inheritance() (localctx IInheritanceContext) {
	localctx = NewInheritanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, WebIDLParserRULE_inheritance)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(321)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__12:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(318)
			p.Match(WebIDLParserT__12)
		}
		{
			p.SetState(319)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	case WebIDLParserT__2:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtensionContext is an interface to support dynamic dispatch.
type IExtensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtensionContext differentiates from other interfaces.
	IsExtensionContext()
}

type ExtensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtensionContext() *ExtensionContext {
	var p = new(ExtensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extension
	return p
}

func (*ExtensionContext) IsExtensionContext() {}

func NewExtensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtensionContext {
	var p = new(ExtensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extension

	return p
}

func (s *ExtensionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtensionContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtension(s)
	}
}

func (s *ExtensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtension(s)
	}
}

func (p *WebIDLParser) Extension() (localctx IExtensionContext) {
	localctx = NewExtensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, WebIDLParserRULE_extension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(326)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__13:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(323)
			p.Match(WebIDLParserT__13)
		}
		{
			p.SetState(324)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	case WebIDLParserT__2:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnum_Context is an interface to support dynamic dispatch.
type IEnum_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_Context differentiates from other interfaces.
	IsEnum_Context()
}

type Enum_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_Context() *Enum_Context {
	var p = new(Enum_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_enum_
	return p
}

func (*Enum_Context) IsEnum_Context() {}

func NewEnum_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_Context {
	var p = new(Enum_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_enum_

	return p
}

func (s *Enum_Context) GetParser() antlr.Parser { return s.parser }

func (s *Enum_Context) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *Enum_Context) EnumValueList() IEnumValueListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumValueListContext)
}

func (s *Enum_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEnum_(s)
	}
}

func (s *Enum_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEnum_(s)
	}
}

func (p *WebIDLParser) Enum_() (localctx IEnum_Context) {
	localctx = NewEnum_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, WebIDLParserRULE_enum_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.Match(WebIDLParserT__14)
	}
	{
		p.SetState(329)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(330)
		p.Match(WebIDLParserT__2)
	}
	{
		p.SetState(331)
		p.EnumValueList()
	}
	{
		p.SetState(332)
		p.Match(WebIDLParserT__3)
	}
	{
		p.SetState(333)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IEnumValueListContext is an interface to support dynamic dispatch.
type IEnumValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueListContext differentiates from other interfaces.
	IsEnumValueListContext()
}

type EnumValueListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueListContext() *EnumValueListContext {
	var p = new(EnumValueListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_enumValueList
	return p
}

func (*EnumValueListContext) IsEnumValueListContext() {}

func NewEnumValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueListContext {
	var p = new(EnumValueListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_enumValueList

	return p
}

func (s *EnumValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueListContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *EnumValueListContext) EnumValueListComma() IEnumValueListCommaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueListCommaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumValueListCommaContext)
}

func (s *EnumValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEnumValueList(s)
	}
}

func (s *EnumValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEnumValueList(s)
	}
}

func (p *WebIDLParser) EnumValueList() (localctx IEnumValueListContext) {
	localctx = NewEnumValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, WebIDLParserRULE_enumValueList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(335)
		p.Match(WebIDLParserSTRING_WEBIDL)
	}
	{
		p.SetState(336)
		p.EnumValueListComma()
	}

	return localctx
}

// IEnumValueListCommaContext is an interface to support dynamic dispatch.
type IEnumValueListCommaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueListCommaContext differentiates from other interfaces.
	IsEnumValueListCommaContext()
}

type EnumValueListCommaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueListCommaContext() *EnumValueListCommaContext {
	var p = new(EnumValueListCommaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_enumValueListComma
	return p
}

func (*EnumValueListCommaContext) IsEnumValueListCommaContext() {}

func NewEnumValueListCommaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueListCommaContext {
	var p = new(EnumValueListCommaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_enumValueListComma

	return p
}

func (s *EnumValueListCommaContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueListCommaContext) EnumValueListString() IEnumValueListStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueListStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumValueListStringContext)
}

func (s *EnumValueListCommaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueListCommaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueListCommaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEnumValueListComma(s)
	}
}

func (s *EnumValueListCommaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEnumValueListComma(s)
	}
}

func (p *WebIDLParser) EnumValueListComma() (localctx IEnumValueListCommaContext) {
	localctx = NewEnumValueListCommaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, WebIDLParserRULE_enumValueListComma)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(341)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(338)
			p.Match(WebIDLParserT__15)
		}
		{
			p.SetState(339)
			p.EnumValueListString()
		}

	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnumValueListStringContext is an interface to support dynamic dispatch.
type IEnumValueListStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumValueListStringContext differentiates from other interfaces.
	IsEnumValueListStringContext()
}

type EnumValueListStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumValueListStringContext() *EnumValueListStringContext {
	var p = new(EnumValueListStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_enumValueListString
	return p
}

func (*EnumValueListStringContext) IsEnumValueListStringContext() {}

func NewEnumValueListStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumValueListStringContext {
	var p = new(EnumValueListStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_enumValueListString

	return p
}

func (s *EnumValueListStringContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumValueListStringContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *EnumValueListStringContext) EnumValueListComma() IEnumValueListCommaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumValueListCommaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumValueListCommaContext)
}

func (s *EnumValueListStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumValueListStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumValueListStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEnumValueListString(s)
	}
}

func (s *EnumValueListStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEnumValueListString(s)
	}
}

func (p *WebIDLParser) EnumValueListString() (localctx IEnumValueListStringContext) {
	localctx = NewEnumValueListStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, WebIDLParserRULE_enumValueListString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(346)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserSTRING_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(343)
			p.Match(WebIDLParserSTRING_WEBIDL)
		}
		{
			p.SetState(344)
			p.EnumValueListComma()
		}

	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallbackRestContext is an interface to support dynamic dispatch.
type ICallbackRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallbackRestContext differentiates from other interfaces.
	IsCallbackRestContext()
}

type CallbackRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallbackRestContext() *CallbackRestContext {
	var p = new(CallbackRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_callbackRest
	return p
}

func (*CallbackRestContext) IsCallbackRestContext() {}

func NewCallbackRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallbackRestContext {
	var p = new(CallbackRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_callbackRest

	return p
}

func (s *CallbackRestContext) GetParser() antlr.Parser { return s.parser }

func (s *CallbackRestContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *CallbackRestContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *CallbackRestContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *CallbackRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallbackRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallbackRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterCallbackRest(s)
	}
}

func (s *CallbackRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitCallbackRest(s)
	}
}

func (p *WebIDLParser) CallbackRest() (localctx ICallbackRestContext) {
	localctx = NewCallbackRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, WebIDLParserRULE_callbackRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(348)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(349)
		p.Match(WebIDLParserT__9)
	}
	{
		p.SetState(350)
		p.ReturnType()
	}
	{
		p.SetState(351)
		p.Match(WebIDLParserT__16)
	}
	{
		p.SetState(352)
		p.ArgumentList()
	}
	{
		p.SetState(353)
		p.Match(WebIDLParserT__17)
	}
	{
		p.SetState(354)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// ITypedefContext is an interface to support dynamic dispatch.
type ITypedefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedefContext differentiates from other interfaces.
	IsTypedefContext()
}

type TypedefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedefContext() *TypedefContext {
	var p = new(TypedefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_typedef
	return p
}

func (*TypedefContext) IsTypedefContext() {}

func NewTypedefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedefContext {
	var p = new(TypedefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_typedef

	return p
}

func (s *TypedefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedefContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypedefContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *TypedefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterTypedef(s)
	}
}

func (s *TypedefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitTypedef(s)
	}
}

func (p *WebIDLParser) Typedef() (localctx ITypedefContext) {
	localctx = NewTypedefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, WebIDLParserRULE_typedef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(356)
		p.Match(WebIDLParserT__18)
	}
	{
		p.SetState(357)
		p.Type()
	}
	{
		p.SetState(358)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(359)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IImplementsStatementContext is an interface to support dynamic dispatch.
type IImplementsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImplementsStatementContext differentiates from other interfaces.
	IsImplementsStatementContext()
}

type ImplementsStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementsStatementContext() *ImplementsStatementContext {
	var p = new(ImplementsStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_implementsStatement
	return p
}

func (*ImplementsStatementContext) IsImplementsStatementContext() {}

func NewImplementsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementsStatementContext {
	var p = new(ImplementsStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_implementsStatement

	return p
}

func (s *ImplementsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementsStatementContext) AllIDENTIFIER_WEBIDL() []antlr.TerminalNode {
	return s.GetTokens(WebIDLParserIDENTIFIER_WEBIDL)
}

func (s *ImplementsStatementContext) IDENTIFIER_WEBIDL(i int) antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, i)
}

func (s *ImplementsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterImplementsStatement(s)
	}
}

func (s *ImplementsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitImplementsStatement(s)
	}
}

func (p *WebIDLParser) ImplementsStatement() (localctx IImplementsStatementContext) {
	localctx = NewImplementsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, WebIDLParserRULE_implementsStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(361)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(362)
		p.Match(WebIDLParserT__19)
	}
	{
		p.SetState(363)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(364)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IConst_Context is an interface to support dynamic dispatch.
type IConst_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_Context differentiates from other interfaces.
	IsConst_Context()
}

type Const_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_Context() *Const_Context {
	var p = new(Const_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_const_
	return p
}

func (*Const_Context) IsConst_Context() {}

func NewConst_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_Context {
	var p = new(Const_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_const_

	return p
}

func (s *Const_Context) GetParser() antlr.Parser { return s.parser }

func (s *Const_Context) ConstType() IConstTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstTypeContext)
}

func (s *Const_Context) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *Const_Context) ConstValue() IConstValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstValueContext)
}

func (s *Const_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterConst_(s)
	}
}

func (s *Const_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitConst_(s)
	}
}

func (p *WebIDLParser) Const_() (localctx IConst_Context) {
	localctx = NewConst_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, WebIDLParserRULE_const_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(366)
		p.Match(WebIDLParserT__20)
	}
	{
		p.SetState(367)
		p.ConstType()
	}
	{
		p.SetState(368)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(369)
		p.Match(WebIDLParserT__9)
	}
	{
		p.SetState(370)
		p.ConstValue()
	}
	{
		p.SetState(371)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IConstValueContext is an interface to support dynamic dispatch.
type IConstValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstValueContext differentiates from other interfaces.
	IsConstValueContext()
}

type ConstValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstValueContext() *ConstValueContext {
	var p = new(ConstValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_constValue
	return p
}

func (*ConstValueContext) IsConstValueContext() {}

func NewConstValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstValueContext {
	var p = new(ConstValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_constValue

	return p
}

func (s *ConstValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstValueContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstValueContext) FloatLiteral() IFloatLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloatLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *ConstValueContext) INTEGER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserINTEGER_WEBIDL, 0)
}

func (s *ConstValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterConstValue(s)
	}
}

func (s *ConstValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitConstValue(s)
	}
}

func (p *WebIDLParser) ConstValue() (localctx IConstValueContext) {
	localctx = NewConstValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, WebIDLParserRULE_constValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(377)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__22, WebIDLParserT__23:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.BooleanLiteral()
		}

	case WebIDLParserT__24, WebIDLParserT__25, WebIDLParserT__26, WebIDLParserFLOAT_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.FloatLiteral()
		}

	case WebIDLParserINTEGER_WEBIDL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(375)
			p.Match(WebIDLParserINTEGER_WEBIDL)
		}

	case WebIDLParserT__21:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(376)
			p.Match(WebIDLParserT__21)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }
func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *WebIDLParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, WebIDLParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(379)
		_la = p.GetTokenStream().LA(1)

		if !(_la == WebIDLParserT__22 || _la == WebIDLParserT__23) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFloatLiteralContext is an interface to support dynamic dispatch.
type IFloatLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloatLiteralContext differentiates from other interfaces.
	IsFloatLiteralContext()
}

type FloatLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatLiteralContext() *FloatLiteralContext {
	var p = new(FloatLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_floatLiteral
	return p
}

func (*FloatLiteralContext) IsFloatLiteralContext() {}

func NewFloatLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_floatLiteral

	return p
}

func (s *FloatLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatLiteralContext) FLOAT_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserFLOAT_WEBIDL, 0)
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

func (p *WebIDLParser) FloatLiteral() (localctx IFloatLiteralContext) {
	localctx = NewFloatLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, WebIDLParserRULE_floatLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<WebIDLParserT__24)|(1<<WebIDLParserT__25)|(1<<WebIDLParserT__26))) != 0) || _la == WebIDLParserFLOAT_WEBIDL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISerializerContext is an interface to support dynamic dispatch.
type ISerializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSerializerContext differentiates from other interfaces.
	IsSerializerContext()
}

type SerializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySerializerContext() *SerializerContext {
	var p = new(SerializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_serializer
	return p
}

func (*SerializerContext) IsSerializerContext() {}

func NewSerializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SerializerContext {
	var p = new(SerializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_serializer

	return p
}

func (s *SerializerContext) GetParser() antlr.Parser { return s.parser }

func (s *SerializerContext) SerializerRest() ISerializerRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISerializerRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISerializerRestContext)
}

func (s *SerializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SerializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSerializer(s)
	}
}

func (s *SerializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSerializer(s)
	}
}

func (p *WebIDLParser) Serializer() (localctx ISerializerContext) {
	localctx = NewSerializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, WebIDLParserRULE_serializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(383)
		p.Match(WebIDLParserT__27)
	}
	{
		p.SetState(384)
		p.SerializerRest()
	}

	return localctx
}

// ISerializerRestContext is an interface to support dynamic dispatch.
type ISerializerRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSerializerRestContext differentiates from other interfaces.
	IsSerializerRestContext()
}

type SerializerRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySerializerRestContext() *SerializerRestContext {
	var p = new(SerializerRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_serializerRest
	return p
}

func (*SerializerRestContext) IsSerializerRestContext() {}

func NewSerializerRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SerializerRestContext {
	var p = new(SerializerRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_serializerRest

	return p
}

func (s *SerializerRestContext) GetParser() antlr.Parser { return s.parser }

func (s *SerializerRestContext) OperationRest() IOperationRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationRestContext)
}

func (s *SerializerRestContext) SerializationPattern() ISerializationPatternContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISerializationPatternContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISerializationPatternContext)
}

func (s *SerializerRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializerRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SerializerRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSerializerRest(s)
	}
}

func (s *SerializerRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSerializerRest(s)
	}
}

func (p *WebIDLParser) SerializerRest() (localctx ISerializerRestContext) {
	localctx = NewSerializerRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, WebIDLParserRULE_serializerRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(392)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__16, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(386)
			p.OperationRest()
		}

	case WebIDLParserT__9:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(387)
			p.Match(WebIDLParserT__9)
		}
		{
			p.SetState(388)
			p.SerializationPattern()
		}
		{
			p.SetState(389)
			p.Match(WebIDLParserT__4)
		}

	case WebIDLParserT__4:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(391)
			p.Match(WebIDLParserT__4)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISerializationPatternContext is an interface to support dynamic dispatch.
type ISerializationPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSerializationPatternContext differentiates from other interfaces.
	IsSerializationPatternContext()
}

type SerializationPatternContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySerializationPatternContext() *SerializationPatternContext {
	var p = new(SerializationPatternContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_serializationPattern
	return p
}

func (*SerializationPatternContext) IsSerializationPatternContext() {}

func NewSerializationPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SerializationPatternContext {
	var p = new(SerializationPatternContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_serializationPattern

	return p
}

func (s *SerializationPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *SerializationPatternContext) SerializationPatternMap() ISerializationPatternMapContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISerializationPatternMapContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISerializationPatternMapContext)
}

func (s *SerializationPatternContext) SerializationPatternList() ISerializationPatternListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISerializationPatternListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISerializationPatternListContext)
}

func (s *SerializationPatternContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *SerializationPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializationPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SerializationPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSerializationPattern(s)
	}
}

func (s *SerializationPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSerializationPattern(s)
	}
}

func (p *WebIDLParser) SerializationPattern() (localctx ISerializationPatternContext) {
	localctx = NewSerializationPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, WebIDLParserRULE_serializationPattern)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(403)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__2:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(394)
			p.Match(WebIDLParserT__2)
		}
		{
			p.SetState(395)
			p.SerializationPatternMap()
		}
		{
			p.SetState(396)
			p.Match(WebIDLParserT__3)
		}

	case WebIDLParserT__10:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(398)
			p.Match(WebIDLParserT__10)
		}
		{
			p.SetState(399)
			p.SerializationPatternList()
		}
		{
			p.SetState(400)
			p.Match(WebIDLParserT__11)
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(402)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISerializationPatternMapContext is an interface to support dynamic dispatch.
type ISerializationPatternMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSerializationPatternMapContext differentiates from other interfaces.
	IsSerializationPatternMapContext()
}

type SerializationPatternMapContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySerializationPatternMapContext() *SerializationPatternMapContext {
	var p = new(SerializationPatternMapContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_serializationPatternMap
	return p
}

func (*SerializationPatternMapContext) IsSerializationPatternMapContext() {}

func NewSerializationPatternMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SerializationPatternMapContext {
	var p = new(SerializationPatternMapContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_serializationPatternMap

	return p
}

func (s *SerializationPatternMapContext) GetParser() antlr.Parser { return s.parser }

func (s *SerializationPatternMapContext) Identifiers() IIdentifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifiersContext)
}

func (s *SerializationPatternMapContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *SerializationPatternMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializationPatternMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SerializationPatternMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSerializationPatternMap(s)
	}
}

func (s *SerializationPatternMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSerializationPatternMap(s)
	}
}

func (p *WebIDLParser) SerializationPatternMap() (localctx ISerializationPatternMapContext) {
	localctx = NewSerializationPatternMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, WebIDLParserRULE_serializationPatternMap)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(411)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__28:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(405)
			p.Match(WebIDLParserT__28)
		}

	case WebIDLParserT__29:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(406)
			p.Match(WebIDLParserT__29)
		}
		{
			p.SetState(407)
			p.Identifiers()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(408)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(409)
			p.Identifiers()
		}

	case WebIDLParserT__3:
		p.EnterOuterAlt(localctx, 4)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISerializationPatternListContext is an interface to support dynamic dispatch.
type ISerializationPatternListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSerializationPatternListContext differentiates from other interfaces.
	IsSerializationPatternListContext()
}

type SerializationPatternListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySerializationPatternListContext() *SerializationPatternListContext {
	var p = new(SerializationPatternListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_serializationPatternList
	return p
}

func (*SerializationPatternListContext) IsSerializationPatternListContext() {}

func NewSerializationPatternListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SerializationPatternListContext {
	var p = new(SerializationPatternListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_serializationPatternList

	return p
}

func (s *SerializationPatternListContext) GetParser() antlr.Parser { return s.parser }

func (s *SerializationPatternListContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *SerializationPatternListContext) Identifiers() IIdentifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifiersContext)
}

func (s *SerializationPatternListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializationPatternListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SerializationPatternListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSerializationPatternList(s)
	}
}

func (s *SerializationPatternListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSerializationPatternList(s)
	}
}

func (p *WebIDLParser) SerializationPatternList() (localctx ISerializationPatternListContext) {
	localctx = NewSerializationPatternListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, WebIDLParserRULE_serializationPatternList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(417)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__28:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(413)
			p.Match(WebIDLParserT__28)
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(414)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(415)
			p.Identifiers()
		}

	case WebIDLParserT__11:
		p.EnterOuterAlt(localctx, 3)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringifierContext is an interface to support dynamic dispatch.
type IStringifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringifierContext differentiates from other interfaces.
	IsStringifierContext()
}

type StringifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringifierContext() *StringifierContext {
	var p = new(StringifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_stringifier
	return p
}

func (*StringifierContext) IsStringifierContext() {}

func NewStringifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringifierContext {
	var p = new(StringifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_stringifier

	return p
}

func (s *StringifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StringifierContext) StringifierRest() IStringifierRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringifierRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringifierRestContext)
}

func (s *StringifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStringifier(s)
	}
}

func (s *StringifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStringifier(s)
	}
}

func (p *WebIDLParser) Stringifier() (localctx IStringifierContext) {
	localctx = NewStringifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, WebIDLParserRULE_stringifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(419)
		p.Match(WebIDLParserT__30)
	}
	{
		p.SetState(420)
		p.StringifierRest()
	}

	return localctx
}

// IStringifierRestContext is an interface to support dynamic dispatch.
type IStringifierRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringifierRestContext differentiates from other interfaces.
	IsStringifierRestContext()
}

type StringifierRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringifierRestContext() *StringifierRestContext {
	var p = new(StringifierRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_stringifierRest
	return p
}

func (*StringifierRestContext) IsStringifierRestContext() {}

func NewStringifierRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringifierRestContext {
	var p = new(StringifierRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_stringifierRest

	return p
}

func (s *StringifierRestContext) GetParser() antlr.Parser { return s.parser }

func (s *StringifierRestContext) ReadOnly() IReadOnlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadOnlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadOnlyContext)
}

func (s *StringifierRestContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *StringifierRestContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *StringifierRestContext) OperationRest() IOperationRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationRestContext)
}

func (s *StringifierRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringifierRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringifierRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStringifierRest(s)
	}
}

func (s *StringifierRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStringifierRest(s)
	}
}

func (p *WebIDLParser) StringifierRest() (localctx IStringifierRestContext) {
	localctx = NewStringifierRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, WebIDLParserRULE_stringifierRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(429)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__32, WebIDLParserT__33:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(422)
			p.ReadOnly()
		}
		{
			p.SetState(423)
			p.AttributeRest()
		}

	case WebIDLParserT__16, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(425)
			p.ReturnType()
		}
		{
			p.SetState(426)
			p.OperationRest()
		}

	case WebIDLParserT__4:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(428)
			p.Match(WebIDLParserT__4)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStaticMemberContext is an interface to support dynamic dispatch.
type IStaticMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticMemberContext differentiates from other interfaces.
	IsStaticMemberContext()
}

type StaticMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticMemberContext() *StaticMemberContext {
	var p = new(StaticMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_staticMember
	return p
}

func (*StaticMemberContext) IsStaticMemberContext() {}

func NewStaticMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticMemberContext {
	var p = new(StaticMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_staticMember

	return p
}

func (s *StaticMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticMemberContext) StaticMemberRest() IStaticMemberRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticMemberRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticMemberRestContext)
}

func (s *StaticMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStaticMember(s)
	}
}

func (s *StaticMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStaticMember(s)
	}
}

func (p *WebIDLParser) StaticMember() (localctx IStaticMemberContext) {
	localctx = NewStaticMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, WebIDLParserRULE_staticMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)
		p.Match(WebIDLParserT__31)
	}
	{
		p.SetState(432)
		p.StaticMemberRest()
	}

	return localctx
}

// IStaticMemberRestContext is an interface to support dynamic dispatch.
type IStaticMemberRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticMemberRestContext differentiates from other interfaces.
	IsStaticMemberRestContext()
}

type StaticMemberRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticMemberRestContext() *StaticMemberRestContext {
	var p = new(StaticMemberRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_staticMemberRest
	return p
}

func (*StaticMemberRestContext) IsStaticMemberRestContext() {}

func NewStaticMemberRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticMemberRestContext {
	var p = new(StaticMemberRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_staticMemberRest

	return p
}

func (s *StaticMemberRestContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticMemberRestContext) ReadOnly() IReadOnlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadOnlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadOnlyContext)
}

func (s *StaticMemberRestContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *StaticMemberRestContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *StaticMemberRestContext) OperationRest() IOperationRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationRestContext)
}

func (s *StaticMemberRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticMemberRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticMemberRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterStaticMemberRest(s)
	}
}

func (s *StaticMemberRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitStaticMemberRest(s)
	}
}

func (p *WebIDLParser) StaticMemberRest() (localctx IStaticMemberRestContext) {
	localctx = NewStaticMemberRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, WebIDLParserRULE_staticMemberRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(440)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__32, WebIDLParserT__33:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(434)
			p.ReadOnly()
		}
		{
			p.SetState(435)
			p.AttributeRest()
		}

	case WebIDLParserT__16, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(437)
			p.ReturnType()
		}
		{
			p.SetState(438)
			p.OperationRest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadonlyMemberContext is an interface to support dynamic dispatch.
type IReadonlyMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadonlyMemberContext differentiates from other interfaces.
	IsReadonlyMemberContext()
}

type ReadonlyMemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadonlyMemberContext() *ReadonlyMemberContext {
	var p = new(ReadonlyMemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readonlyMember
	return p
}

func (*ReadonlyMemberContext) IsReadonlyMemberContext() {}

func NewReadonlyMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadonlyMemberContext {
	var p = new(ReadonlyMemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readonlyMember

	return p
}

func (s *ReadonlyMemberContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadonlyMemberContext) ReadonlyMemberRest() IReadonlyMemberRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadonlyMemberRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadonlyMemberRestContext)
}

func (s *ReadonlyMemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadonlyMemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadonlyMemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadonlyMember(s)
	}
}

func (s *ReadonlyMemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadonlyMember(s)
	}
}

func (p *WebIDLParser) ReadonlyMember() (localctx IReadonlyMemberContext) {
	localctx = NewReadonlyMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, WebIDLParserRULE_readonlyMember)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(442)
		p.Match(WebIDLParserT__32)
	}
	{
		p.SetState(443)
		p.ReadonlyMemberRest()
	}

	return localctx
}

// IReadonlyMemberRestContext is an interface to support dynamic dispatch.
type IReadonlyMemberRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadonlyMemberRestContext differentiates from other interfaces.
	IsReadonlyMemberRestContext()
}

type ReadonlyMemberRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadonlyMemberRestContext() *ReadonlyMemberRestContext {
	var p = new(ReadonlyMemberRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readonlyMemberRest
	return p
}

func (*ReadonlyMemberRestContext) IsReadonlyMemberRestContext() {}

func NewReadonlyMemberRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadonlyMemberRestContext {
	var p = new(ReadonlyMemberRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readonlyMemberRest

	return p
}

func (s *ReadonlyMemberRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadonlyMemberRestContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *ReadonlyMemberRestContext) ReadWriteMaplike() IReadWriteMaplikeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWriteMaplikeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWriteMaplikeContext)
}

func (s *ReadonlyMemberRestContext) ReadWriteSetlike() IReadWriteSetlikeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadWriteSetlikeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadWriteSetlikeContext)
}

func (s *ReadonlyMemberRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadonlyMemberRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadonlyMemberRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadonlyMemberRest(s)
	}
}

func (s *ReadonlyMemberRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadonlyMemberRest(s)
	}
}

func (p *WebIDLParser) ReadonlyMemberRest() (localctx IReadonlyMemberRestContext) {
	localctx = NewReadonlyMemberRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, WebIDLParserRULE_readonlyMemberRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(448)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__33:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(445)
			p.AttributeRest()
		}

	case WebIDLParserT__42:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(446)
			p.ReadWriteMaplike()
		}

	case WebIDLParserT__43:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(447)
			p.ReadWriteSetlike()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadWriteAttributeContext is an interface to support dynamic dispatch.
type IReadWriteAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWriteAttributeContext differentiates from other interfaces.
	IsReadWriteAttributeContext()
}

type ReadWriteAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWriteAttributeContext() *ReadWriteAttributeContext {
	var p = new(ReadWriteAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readWriteAttribute
	return p
}

func (*ReadWriteAttributeContext) IsReadWriteAttributeContext() {}

func NewReadWriteAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWriteAttributeContext {
	var p = new(ReadWriteAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readWriteAttribute

	return p
}

func (s *ReadWriteAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWriteAttributeContext) ReadOnly() IReadOnlyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadOnlyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadOnlyContext)
}

func (s *ReadWriteAttributeContext) AttributeRest() IAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeRestContext)
}

func (s *ReadWriteAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWriteAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWriteAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadWriteAttribute(s)
	}
}

func (s *ReadWriteAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadWriteAttribute(s)
	}
}

func (p *WebIDLParser) ReadWriteAttribute() (localctx IReadWriteAttributeContext) {
	localctx = NewReadWriteAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, WebIDLParserRULE_readWriteAttribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(455)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__29:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(450)
			p.Match(WebIDLParserT__29)
		}
		{
			p.SetState(451)
			p.ReadOnly()
		}
		{
			p.SetState(452)
			p.AttributeRest()
		}

	case WebIDLParserT__33:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(454)
			p.AttributeRest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttributeRestContext is an interface to support dynamic dispatch.
type IAttributeRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeRestContext differentiates from other interfaces.
	IsAttributeRestContext()
}

type AttributeRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeRestContext() *AttributeRestContext {
	var p = new(AttributeRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_attributeRest
	return p
}

func (*AttributeRestContext) IsAttributeRestContext() {}

func NewAttributeRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeRestContext {
	var p = new(AttributeRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_attributeRest

	return p
}

func (s *AttributeRestContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeRestContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *AttributeRestContext) AttributeName() IAttributeNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameContext)
}

func (s *AttributeRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterAttributeRest(s)
	}
}

func (s *AttributeRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitAttributeRest(s)
	}
}

func (p *WebIDLParser) AttributeRest() (localctx IAttributeRestContext) {
	localctx = NewAttributeRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, WebIDLParserRULE_attributeRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(WebIDLParserT__33)
	}
	{
		p.SetState(458)
		p.Type()
	}
	{
		p.SetState(459)
		p.AttributeName()
	}
	{
		p.SetState(460)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IAttributeNameContext is an interface to support dynamic dispatch.
type IAttributeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeNameContext differentiates from other interfaces.
	IsAttributeNameContext()
}

type AttributeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameContext() *AttributeNameContext {
	var p = new(AttributeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_attributeName
	return p
}

func (*AttributeNameContext) IsAttributeNameContext() {}

func NewAttributeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameContext {
	var p = new(AttributeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_attributeName

	return p
}

func (s *AttributeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNameContext) AttributeNameKeyword() IAttributeNameKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNameKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNameKeywordContext)
}

func (s *AttributeNameContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *AttributeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterAttributeName(s)
	}
}

func (s *AttributeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitAttributeName(s)
	}
}

func (p *WebIDLParser) AttributeName() (localctx IAttributeNameContext) {
	localctx = NewAttributeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, WebIDLParserRULE_attributeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(464)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__8:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(462)
			p.AttributeNameKeyword()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(463)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttributeNameKeywordContext is an interface to support dynamic dispatch.
type IAttributeNameKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeNameKeywordContext differentiates from other interfaces.
	IsAttributeNameKeywordContext()
}

type AttributeNameKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNameKeywordContext() *AttributeNameKeywordContext {
	var p = new(AttributeNameKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_attributeNameKeyword
	return p
}

func (*AttributeNameKeywordContext) IsAttributeNameKeywordContext() {}

func NewAttributeNameKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNameKeywordContext {
	var p = new(AttributeNameKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_attributeNameKeyword

	return p
}

func (s *AttributeNameKeywordContext) GetParser() antlr.Parser { return s.parser }
func (s *AttributeNameKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNameKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNameKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterAttributeNameKeyword(s)
	}
}

func (s *AttributeNameKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitAttributeNameKeyword(s)
	}
}

func (p *WebIDLParser) AttributeNameKeyword() (localctx IAttributeNameKeywordContext) {
	localctx = NewAttributeNameKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, WebIDLParserRULE_attributeNameKeyword)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Match(WebIDLParserT__8)
	}

	return localctx
}

// IInheritContext is an interface to support dynamic dispatch.
type IInheritContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInheritContext differentiates from other interfaces.
	IsInheritContext()
}

type InheritContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInheritContext() *InheritContext {
	var p = new(InheritContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_inherit
	return p
}

func (*InheritContext) IsInheritContext() {}

func NewInheritContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InheritContext {
	var p = new(InheritContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_inherit

	return p
}

func (s *InheritContext) GetParser() antlr.Parser { return s.parser }
func (s *InheritContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InheritContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InheritContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterInherit(s)
	}
}

func (s *InheritContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitInherit(s)
	}
}

func (p *WebIDLParser) Inherit() (localctx IInheritContext) {
	localctx = NewInheritContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, WebIDLParserRULE_inherit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(470)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__29:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(468)
			p.Match(WebIDLParserT__29)
		}

	case WebIDLParserEOF:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadOnlyContext is an interface to support dynamic dispatch.
type IReadOnlyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadOnlyContext differentiates from other interfaces.
	IsReadOnlyContext()
}

type ReadOnlyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadOnlyContext() *ReadOnlyContext {
	var p = new(ReadOnlyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readOnly
	return p
}

func (*ReadOnlyContext) IsReadOnlyContext() {}

func NewReadOnlyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadOnlyContext {
	var p = new(ReadOnlyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readOnly

	return p
}

func (s *ReadOnlyContext) GetParser() antlr.Parser { return s.parser }
func (s *ReadOnlyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadOnlyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadOnlyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadOnly(s)
	}
}

func (s *ReadOnlyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadOnly(s)
	}
}

func (p *WebIDLParser) ReadOnly() (localctx IReadOnlyContext) {
	localctx = NewReadOnlyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, WebIDLParserRULE_readOnly)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(474)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__32:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(472)
			p.Match(WebIDLParserT__32)
		}

	case WebIDLParserT__33:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOperationContext is an interface to support dynamic dispatch.
type IOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationContext differentiates from other interfaces.
	IsOperationContext()
}

type OperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationContext() *OperationContext {
	var p = new(OperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_operation
	return p
}

func (*OperationContext) IsOperationContext() {}

func NewOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationContext {
	var p = new(OperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_operation

	return p
}

func (s *OperationContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *OperationContext) OperationRest() IOperationRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationRestContext)
}

func (s *OperationContext) SpecialOperation() ISpecialOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialOperationContext)
}

func (s *OperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOperation(s)
	}
}

func (s *OperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOperation(s)
	}
}

func (p *WebIDLParser) Operation() (localctx IOperationContext) {
	localctx = NewOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, WebIDLParserRULE_operation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(480)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__16, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(476)
			p.ReturnType()
		}
		{
			p.SetState(477)
			p.OperationRest()
		}

	case WebIDLParserT__28, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(479)
			p.SpecialOperation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpecialOperationContext is an interface to support dynamic dispatch.
type ISpecialOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialOperationContext differentiates from other interfaces.
	IsSpecialOperationContext()
}

type SpecialOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialOperationContext() *SpecialOperationContext {
	var p = new(SpecialOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_specialOperation
	return p
}

func (*SpecialOperationContext) IsSpecialOperationContext() {}

func NewSpecialOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialOperationContext {
	var p = new(SpecialOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_specialOperation

	return p
}

func (s *SpecialOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialOperationContext) Special() ISpecialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialContext)
}

func (s *SpecialOperationContext) Specials() ISpecialsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialsContext)
}

func (s *SpecialOperationContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *SpecialOperationContext) OperationRest() IOperationRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOperationRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOperationRestContext)
}

func (s *SpecialOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSpecialOperation(s)
	}
}

func (s *SpecialOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSpecialOperation(s)
	}
}

func (p *WebIDLParser) SpecialOperation() (localctx ISpecialOperationContext) {
	localctx = NewSpecialOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, WebIDLParserRULE_specialOperation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.Special()
	}
	{
		p.SetState(483)
		p.Specials()
	}
	{
		p.SetState(484)
		p.ReturnType()
	}
	{
		p.SetState(485)
		p.OperationRest()
	}

	return localctx
}

// ISpecialsContext is an interface to support dynamic dispatch.
type ISpecialsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialsContext differentiates from other interfaces.
	IsSpecialsContext()
}

type SpecialsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialsContext() *SpecialsContext {
	var p = new(SpecialsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_specials
	return p
}

func (*SpecialsContext) IsSpecialsContext() {}

func NewSpecialsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialsContext {
	var p = new(SpecialsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_specials

	return p
}

func (s *SpecialsContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialsContext) Special() ISpecialContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialContext)
}

func (s *SpecialsContext) Specials() ISpecialsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecialsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecialsContext)
}

func (s *SpecialsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSpecials(s)
	}
}

func (s *SpecialsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSpecials(s)
	}
}

func (p *WebIDLParser) Specials() (localctx ISpecialsContext) {
	localctx = NewSpecialsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, WebIDLParserRULE_specials)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(491)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__28, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(487)
			p.Special()
		}
		{
			p.SetState(488)
			p.Specials()
		}

	case WebIDLParserT__16, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpecialContext is an interface to support dynamic dispatch.
type ISpecialContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialContext differentiates from other interfaces.
	IsSpecialContext()
}

type SpecialContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialContext() *SpecialContext {
	var p = new(SpecialContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_special
	return p
}

func (*SpecialContext) IsSpecialContext() {}

func NewSpecialContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialContext {
	var p = new(SpecialContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_special

	return p
}

func (s *SpecialContext) GetParser() antlr.Parser { return s.parser }
func (s *SpecialContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSpecial(s)
	}
}

func (s *SpecialContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSpecial(s)
	}
}

func (p *WebIDLParser) Special() (localctx ISpecialContext) {
	localctx = NewSpecialContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, WebIDLParserRULE_special)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-29)&-(0x1f+1)) == 0 && ((1<<uint((_la-29)))&((1<<(WebIDLParserT__28-29))|(1<<(WebIDLParserT__34-29))|(1<<(WebIDLParserT__35-29))|(1<<(WebIDLParserT__36-29)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOperationRestContext is an interface to support dynamic dispatch.
type IOperationRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationRestContext differentiates from other interfaces.
	IsOperationRestContext()
}

type OperationRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationRestContext() *OperationRestContext {
	var p = new(OperationRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_operationRest
	return p
}

func (*OperationRestContext) IsOperationRestContext() {}

func NewOperationRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationRestContext {
	var p = new(OperationRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_operationRest

	return p
}

func (s *OperationRestContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationRestContext) OptionalIdentifier() IOptionalIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalIdentifierContext)
}

func (s *OperationRestContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *OperationRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOperationRest(s)
	}
}

func (s *OperationRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOperationRest(s)
	}
}

func (p *WebIDLParser) OperationRest() (localctx IOperationRestContext) {
	localctx = NewOperationRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, WebIDLParserRULE_operationRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.OptionalIdentifier()
	}
	{
		p.SetState(496)
		p.Match(WebIDLParserT__16)
	}
	{
		p.SetState(497)
		p.ArgumentList()
	}
	{
		p.SetState(498)
		p.Match(WebIDLParserT__17)
	}
	{
		p.SetState(499)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IOptionalIdentifierContext is an interface to support dynamic dispatch.
type IOptionalIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalIdentifierContext differentiates from other interfaces.
	IsOptionalIdentifierContext()
}

type OptionalIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalIdentifierContext() *OptionalIdentifierContext {
	var p = new(OptionalIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalIdentifier
	return p
}

func (*OptionalIdentifierContext) IsOptionalIdentifierContext() {}

func NewOptionalIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalIdentifierContext {
	var p = new(OptionalIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalIdentifier

	return p
}

func (s *OptionalIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalIdentifierContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *OptionalIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalIdentifier(s)
	}
}

func (s *OptionalIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalIdentifier(s)
	}
}

func (p *WebIDLParser) OptionalIdentifier() (localctx IOptionalIdentifierContext) {
	localctx = NewOptionalIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, WebIDLParserRULE_optionalIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(503)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(501)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	case WebIDLParserT__16:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argumentList
	return p
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) Argument() IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentListContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *WebIDLParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, WebIDLParserRULE_argumentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(509)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__10, WebIDLParserT__16, WebIDLParserT__37, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.Argument()
		}
		{
			p.SetState(506)
			p.Arguments()
		}

	case WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) Argument() IArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentsContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *WebIDLParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, WebIDLParserRULE_arguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(516)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(511)
			p.Match(WebIDLParserT__15)
		}
		{
			p.SetState(512)
			p.Argument()
		}
		{
			p.SetState(513)
			p.Arguments()
		}

	case WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) ExtendedAttributeList() IExtendedAttributeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeListContext)
}

func (s *ArgumentContext) OptionalOrRequiredArgument() IOptionalOrRequiredArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalOrRequiredArgumentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalOrRequiredArgumentContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (p *WebIDLParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, WebIDLParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.ExtendedAttributeList()
	}
	{
		p.SetState(519)
		p.OptionalOrRequiredArgument()
	}

	return localctx
}

// IOptionalOrRequiredArgumentContext is an interface to support dynamic dispatch.
type IOptionalOrRequiredArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalOrRequiredArgumentContext differentiates from other interfaces.
	IsOptionalOrRequiredArgumentContext()
}

type OptionalOrRequiredArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalOrRequiredArgumentContext() *OptionalOrRequiredArgumentContext {
	var p = new(OptionalOrRequiredArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalOrRequiredArgument
	return p
}

func (*OptionalOrRequiredArgumentContext) IsOptionalOrRequiredArgumentContext() {}

func NewOptionalOrRequiredArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalOrRequiredArgumentContext {
	var p = new(OptionalOrRequiredArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalOrRequiredArgument

	return p
}

func (s *OptionalOrRequiredArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalOrRequiredArgumentContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *OptionalOrRequiredArgumentContext) ArgumentName() IArgumentNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentNameContext)
}

func (s *OptionalOrRequiredArgumentContext) Default_() IDefault_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefault_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDefault_Context)
}

func (s *OptionalOrRequiredArgumentContext) Ellipsis() IEllipsisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEllipsisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEllipsisContext)
}

func (s *OptionalOrRequiredArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalOrRequiredArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalOrRequiredArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalOrRequiredArgument(s)
	}
}

func (s *OptionalOrRequiredArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalOrRequiredArgument(s)
	}
}

func (p *WebIDLParser) OptionalOrRequiredArgument() (localctx IOptionalOrRequiredArgumentContext) {
	localctx = NewOptionalOrRequiredArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, WebIDLParserRULE_optionalOrRequiredArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(530)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__37:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(521)
			p.Match(WebIDLParserT__37)
		}
		{
			p.SetState(522)
			p.Type()
		}
		{
			p.SetState(523)
			p.ArgumentName()
		}
		{
			p.SetState(524)
			p.Default_()
		}

	case WebIDLParserT__16, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(526)
			p.Type()
		}
		{
			p.SetState(527)
			p.Ellipsis()
		}
		{
			p.SetState(528)
			p.ArgumentName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentNameContext is an interface to support dynamic dispatch.
type IArgumentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentNameContext differentiates from other interfaces.
	IsArgumentNameContext()
}

type ArgumentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentNameContext() *ArgumentNameContext {
	var p = new(ArgumentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argumentName
	return p
}

func (*ArgumentNameContext) IsArgumentNameContext() {}

func NewArgumentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentNameContext {
	var p = new(ArgumentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argumentName

	return p
}

func (s *ArgumentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentNameContext) ArgumentNameKeyword() IArgumentNameKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentNameKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentNameKeywordContext)
}

func (s *ArgumentNameContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ArgumentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgumentName(s)
	}
}

func (s *ArgumentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgumentName(s)
	}
}

func (p *WebIDLParser) ArgumentName() (localctx IArgumentNameContext) {
	localctx = NewArgumentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, WebIDLParserRULE_argumentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(534)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__14, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__39, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__65:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(532)
			p.ArgumentNameKeyword()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(533)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEllipsisContext is an interface to support dynamic dispatch.
type IEllipsisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEllipsisContext differentiates from other interfaces.
	IsEllipsisContext()
}

type EllipsisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEllipsisContext() *EllipsisContext {
	var p = new(EllipsisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_ellipsis
	return p
}

func (*EllipsisContext) IsEllipsisContext() {}

func NewEllipsisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EllipsisContext {
	var p = new(EllipsisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_ellipsis

	return p
}

func (s *EllipsisContext) GetParser() antlr.Parser { return s.parser }
func (s *EllipsisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EllipsisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EllipsisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterEllipsis(s)
	}
}

func (s *EllipsisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitEllipsis(s)
	}
}

func (p *WebIDLParser) Ellipsis() (localctx IEllipsisContext) {
	localctx = NewEllipsisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, WebIDLParserRULE_ellipsis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__38:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(536)
			p.Match(WebIDLParserT__38)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__14, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__39, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__65, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIterableContext is an interface to support dynamic dispatch.
type IIterableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIterableContext differentiates from other interfaces.
	IsIterableContext()
}

type IterableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterableContext() *IterableContext {
	var p = new(IterableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_iterable
	return p
}

func (*IterableContext) IsIterableContext() {}

func NewIterableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterableContext {
	var p = new(IterableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_iterable

	return p
}

func (s *IterableContext) GetParser() antlr.Parser { return s.parser }

func (s *IterableContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *IterableContext) OptionalType() IOptionalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalTypeContext)
}

func (s *IterableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIterable(s)
	}
}

func (s *IterableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIterable(s)
	}
}

func (p *WebIDLParser) Iterable() (localctx IIterableContext) {
	localctx = NewIterableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, WebIDLParserRULE_iterable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)
		p.Match(WebIDLParserT__39)
	}
	{
		p.SetState(541)
		p.Match(WebIDLParserT__40)
	}
	{
		p.SetState(542)
		p.Type()
	}
	{
		p.SetState(543)
		p.OptionalType()
	}
	{
		p.SetState(544)
		p.Match(WebIDLParserT__41)
	}
	{
		p.SetState(545)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IOptionalTypeContext is an interface to support dynamic dispatch.
type IOptionalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalTypeContext differentiates from other interfaces.
	IsOptionalTypeContext()
}

type OptionalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalTypeContext() *OptionalTypeContext {
	var p = new(OptionalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalType
	return p
}

func (*OptionalTypeContext) IsOptionalTypeContext() {}

func NewOptionalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalTypeContext {
	var p = new(OptionalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalType

	return p
}

func (s *OptionalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionalTypeContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *OptionalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalType(s)
	}
}

func (s *OptionalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalType(s)
	}
}

func (p *WebIDLParser) OptionalType() (localctx IOptionalTypeContext) {
	localctx = NewOptionalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, WebIDLParserRULE_optionalType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(550)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(547)
			p.Match(WebIDLParserT__15)
		}
		{
			p.SetState(548)
			p.Type()
		}

	case WebIDLParserT__41:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadWriteMaplikeContext is an interface to support dynamic dispatch.
type IReadWriteMaplikeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWriteMaplikeContext differentiates from other interfaces.
	IsReadWriteMaplikeContext()
}

type ReadWriteMaplikeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWriteMaplikeContext() *ReadWriteMaplikeContext {
	var p = new(ReadWriteMaplikeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readWriteMaplike
	return p
}

func (*ReadWriteMaplikeContext) IsReadWriteMaplikeContext() {}

func NewReadWriteMaplikeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWriteMaplikeContext {
	var p = new(ReadWriteMaplikeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readWriteMaplike

	return p
}

func (s *ReadWriteMaplikeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWriteMaplikeContext) MaplikeRest() IMaplikeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMaplikeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMaplikeRestContext)
}

func (s *ReadWriteMaplikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWriteMaplikeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWriteMaplikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadWriteMaplike(s)
	}
}

func (s *ReadWriteMaplikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadWriteMaplike(s)
	}
}

func (p *WebIDLParser) ReadWriteMaplike() (localctx IReadWriteMaplikeContext) {
	localctx = NewReadWriteMaplikeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, WebIDLParserRULE_readWriteMaplike)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.MaplikeRest()
	}

	return localctx
}

// IReadWriteSetlikeContext is an interface to support dynamic dispatch.
type IReadWriteSetlikeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWriteSetlikeContext differentiates from other interfaces.
	IsReadWriteSetlikeContext()
}

type ReadWriteSetlikeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWriteSetlikeContext() *ReadWriteSetlikeContext {
	var p = new(ReadWriteSetlikeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_readWriteSetlike
	return p
}

func (*ReadWriteSetlikeContext) IsReadWriteSetlikeContext() {}

func NewReadWriteSetlikeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWriteSetlikeContext {
	var p = new(ReadWriteSetlikeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_readWriteSetlike

	return p
}

func (s *ReadWriteSetlikeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWriteSetlikeContext) SetlikeRest() ISetlikeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetlikeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetlikeRestContext)
}

func (s *ReadWriteSetlikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWriteSetlikeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWriteSetlikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReadWriteSetlike(s)
	}
}

func (s *ReadWriteSetlikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReadWriteSetlike(s)
	}
}

func (p *WebIDLParser) ReadWriteSetlike() (localctx IReadWriteSetlikeContext) {
	localctx = NewReadWriteSetlikeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, WebIDLParserRULE_readWriteSetlike)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(554)
		p.SetlikeRest()
	}

	return localctx
}

// IMaplikeRestContext is an interface to support dynamic dispatch.
type IMaplikeRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMaplikeRestContext differentiates from other interfaces.
	IsMaplikeRestContext()
}

type MaplikeRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaplikeRestContext() *MaplikeRestContext {
	var p = new(MaplikeRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_maplikeRest
	return p
}

func (*MaplikeRestContext) IsMaplikeRestContext() {}

func NewMaplikeRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaplikeRestContext {
	var p = new(MaplikeRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_maplikeRest

	return p
}

func (s *MaplikeRestContext) GetParser() antlr.Parser { return s.parser }

func (s *MaplikeRestContext) AllType() []ITypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeContext)(nil)).Elem())
	var tst = make([]ITypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeContext)
		}
	}

	return tst
}

func (s *MaplikeRestContext) Type(i int) ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *MaplikeRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaplikeRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaplikeRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterMaplikeRest(s)
	}
}

func (s *MaplikeRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitMaplikeRest(s)
	}
}

func (p *WebIDLParser) MaplikeRest() (localctx IMaplikeRestContext) {
	localctx = NewMaplikeRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, WebIDLParserRULE_maplikeRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Match(WebIDLParserT__42)
	}
	{
		p.SetState(557)
		p.Match(WebIDLParserT__40)
	}
	{
		p.SetState(558)
		p.Type()
	}
	{
		p.SetState(559)
		p.Match(WebIDLParserT__15)
	}
	{
		p.SetState(560)
		p.Type()
	}
	{
		p.SetState(561)
		p.Match(WebIDLParserT__41)
	}
	{
		p.SetState(562)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// ISetlikeRestContext is an interface to support dynamic dispatch.
type ISetlikeRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetlikeRestContext differentiates from other interfaces.
	IsSetlikeRestContext()
}

type SetlikeRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetlikeRestContext() *SetlikeRestContext {
	var p = new(SetlikeRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_setlikeRest
	return p
}

func (*SetlikeRestContext) IsSetlikeRestContext() {}

func NewSetlikeRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetlikeRestContext {
	var p = new(SetlikeRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_setlikeRest

	return p
}

func (s *SetlikeRestContext) GetParser() antlr.Parser { return s.parser }

func (s *SetlikeRestContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SetlikeRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetlikeRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetlikeRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSetlikeRest(s)
	}
}

func (s *SetlikeRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSetlikeRest(s)
	}
}

func (p *WebIDLParser) SetlikeRest() (localctx ISetlikeRestContext) {
	localctx = NewSetlikeRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, WebIDLParserRULE_setlikeRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Match(WebIDLParserT__43)
	}
	{
		p.SetState(565)
		p.Match(WebIDLParserT__40)
	}
	{
		p.SetState(566)
		p.Type()
	}
	{
		p.SetState(567)
		p.Match(WebIDLParserT__41)
	}
	{
		p.SetState(568)
		p.Match(WebIDLParserT__4)
	}

	return localctx
}

// IExtendedAttributeListContext is an interface to support dynamic dispatch.
type IExtendedAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeListContext differentiates from other interfaces.
	IsExtendedAttributeListContext()
}

type ExtendedAttributeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeListContext() *ExtendedAttributeListContext {
	var p = new(ExtendedAttributeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeList
	return p
}

func (*ExtendedAttributeListContext) IsExtendedAttributeListContext() {}

func NewExtendedAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeListContext {
	var p = new(ExtendedAttributeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeList

	return p
}

func (s *ExtendedAttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeListContext) ExtendedAttribute() IExtendedAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeContext)
}

func (s *ExtendedAttributeListContext) ExtendedAttributes() IExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributesContext)
}

func (s *ExtendedAttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeList(s)
	}
}

func (s *ExtendedAttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeList() (localctx IExtendedAttributeListContext) {
	localctx = NewExtendedAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, WebIDLParserRULE_extendedAttributeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(576)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__10:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(570)
			p.Match(WebIDLParserT__10)
		}
		{
			p.SetState(571)
			p.ExtendedAttribute()
		}
		{
			p.SetState(572)
			p.ExtendedAttributes()
		}
		{
			p.SetState(573)
			p.Match(WebIDLParserT__11)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__5, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__14, WebIDLParserT__16, WebIDLParserT__18, WebIDLParserT__20, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__32, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__37, WebIDLParserT__39, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendedAttributesContext is an interface to support dynamic dispatch.
type IExtendedAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributesContext differentiates from other interfaces.
	IsExtendedAttributesContext()
}

type ExtendedAttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributesContext() *ExtendedAttributesContext {
	var p = new(ExtendedAttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributes
	return p
}

func (*ExtendedAttributesContext) IsExtendedAttributesContext() {}

func NewExtendedAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributesContext {
	var p = new(ExtendedAttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributes

	return p
}

func (s *ExtendedAttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributesContext) ExtendedAttribute() IExtendedAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeContext)
}

func (s *ExtendedAttributesContext) ExtendedAttributes() IExtendedAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributesContext)
}

func (s *ExtendedAttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributes(s)
	}
}

func (s *ExtendedAttributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributes(s)
	}
}

func (p *WebIDLParser) ExtendedAttributes() (localctx IExtendedAttributesContext) {
	localctx = NewExtendedAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, WebIDLParserRULE_extendedAttributes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(583)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(578)
			p.Match(WebIDLParserT__15)
		}
		{
			p.SetState(579)
			p.ExtendedAttribute()
		}
		{
			p.SetState(580)
			p.ExtendedAttributes()
		}

	case WebIDLParserT__11:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendedAttributeContext is an interface to support dynamic dispatch.
type IExtendedAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeContext differentiates from other interfaces.
	IsExtendedAttributeContext()
}

type ExtendedAttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeContext() *ExtendedAttributeContext {
	var p = new(ExtendedAttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttribute
	return p
}

func (*ExtendedAttributeContext) IsExtendedAttributeContext() {}

func NewExtendedAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeContext {
	var p = new(ExtendedAttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttribute

	return p
}

func (s *ExtendedAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeContext) ExtendedAttributeInner() IExtendedAttributeInnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeInnerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeInnerContext)
}

func (s *ExtendedAttributeContext) ExtendedAttributeRest() IExtendedAttributeRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeRestContext)
}

func (s *ExtendedAttributeContext) Other() IOtherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOtherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOtherContext)
}

func (s *ExtendedAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttribute(s)
	}
}

func (s *ExtendedAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttribute(s)
	}
}

func (p *WebIDLParser) ExtendedAttribute() (localctx IExtendedAttributeContext) {
	localctx = NewExtendedAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, WebIDLParserRULE_extendedAttribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(603)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(585)
			p.Match(WebIDLParserT__16)
		}
		{
			p.SetState(586)
			p.ExtendedAttributeInner()
		}
		{
			p.SetState(587)
			p.Match(WebIDLParserT__17)
		}
		{
			p.SetState(588)
			p.ExtendedAttributeRest()
		}

	case WebIDLParserT__10:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(590)
			p.Match(WebIDLParserT__10)
		}
		{
			p.SetState(591)
			p.ExtendedAttributeInner()
		}
		{
			p.SetState(592)
			p.Match(WebIDLParserT__11)
		}
		{
			p.SetState(593)
			p.ExtendedAttributeRest()
		}

	case WebIDLParserT__2:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(595)
			p.Match(WebIDLParserT__2)
		}
		{
			p.SetState(596)
			p.ExtendedAttributeInner()
		}
		{
			p.SetState(597)
			p.Match(WebIDLParserT__3)
		}
		{
			p.SetState(598)
			p.ExtendedAttributeRest()
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__4, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__12, WebIDLParserT__14, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__25, WebIDLParserT__26, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__37, WebIDLParserT__38, WebIDLParserT__39, WebIDLParserT__40, WebIDLParserT__41, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__44, WebIDLParserT__45, WebIDLParserT__46, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserINTEGER_WEBIDL, WebIDLParserFLOAT_WEBIDL, WebIDLParserIDENTIFIER_WEBIDL, WebIDLParserSTRING_WEBIDL, WebIDLParserOTHER_WEBIDL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(600)
			p.Other()
		}
		{
			p.SetState(601)
			p.ExtendedAttributeRest()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendedAttributeRestContext is an interface to support dynamic dispatch.
type IExtendedAttributeRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeRestContext differentiates from other interfaces.
	IsExtendedAttributeRestContext()
}

type ExtendedAttributeRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeRestContext() *ExtendedAttributeRestContext {
	var p = new(ExtendedAttributeRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeRest
	return p
}

func (*ExtendedAttributeRestContext) IsExtendedAttributeRestContext() {}

func NewExtendedAttributeRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeRestContext {
	var p = new(ExtendedAttributeRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeRest

	return p
}

func (s *ExtendedAttributeRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeRestContext) ExtendedAttribute() IExtendedAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeContext)
}

func (s *ExtendedAttributeRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeRest(s)
	}
}

func (s *ExtendedAttributeRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeRest(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeRest() (localctx IExtendedAttributeRestContext) {
	localctx = NewExtendedAttributeRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, WebIDLParserRULE_extendedAttributeRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(607)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__2, WebIDLParserT__4, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__10, WebIDLParserT__12, WebIDLParserT__14, WebIDLParserT__16, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__25, WebIDLParserT__26, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__37, WebIDLParserT__38, WebIDLParserT__39, WebIDLParserT__40, WebIDLParserT__41, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__44, WebIDLParserT__45, WebIDLParserT__46, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserINTEGER_WEBIDL, WebIDLParserFLOAT_WEBIDL, WebIDLParserIDENTIFIER_WEBIDL, WebIDLParserSTRING_WEBIDL, WebIDLParserOTHER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(605)
			p.ExtendedAttribute()
		}

	case WebIDLParserT__11, WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendedAttributeInnerContext is an interface to support dynamic dispatch.
type IExtendedAttributeInnerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeInnerContext differentiates from other interfaces.
	IsExtendedAttributeInnerContext()
}

type ExtendedAttributeInnerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeInnerContext() *ExtendedAttributeInnerContext {
	var p = new(ExtendedAttributeInnerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeInner
	return p
}

func (*ExtendedAttributeInnerContext) IsExtendedAttributeInnerContext() {}

func NewExtendedAttributeInnerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeInnerContext {
	var p = new(ExtendedAttributeInnerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeInner

	return p
}

func (s *ExtendedAttributeInnerContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeInnerContext) AllExtendedAttributeInner() []IExtendedAttributeInnerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExtendedAttributeInnerContext)(nil)).Elem())
	var tst = make([]IExtendedAttributeInnerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExtendedAttributeInnerContext)
		}
	}

	return tst
}

func (s *ExtendedAttributeInnerContext) ExtendedAttributeInner(i int) IExtendedAttributeInnerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExtendedAttributeInnerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExtendedAttributeInnerContext)
}

func (s *ExtendedAttributeInnerContext) OtherOrComma() IOtherOrCommaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOtherOrCommaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOtherOrCommaContext)
}

func (s *ExtendedAttributeInnerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeInnerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeInnerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeInner(s)
	}
}

func (s *ExtendedAttributeInnerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeInner(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeInner() (localctx IExtendedAttributeInnerContext) {
	localctx = NewExtendedAttributeInnerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, WebIDLParserRULE_extendedAttributeInner)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(628)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__16:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(609)
			p.Match(WebIDLParserT__16)
		}
		{
			p.SetState(610)
			p.ExtendedAttributeInner()
		}
		{
			p.SetState(611)
			p.Match(WebIDLParserT__17)
		}
		{
			p.SetState(612)
			p.ExtendedAttributeInner()
		}

	case WebIDLParserT__10:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(614)
			p.Match(WebIDLParserT__10)
		}
		{
			p.SetState(615)
			p.ExtendedAttributeInner()
		}
		{
			p.SetState(616)
			p.Match(WebIDLParserT__11)
		}
		{
			p.SetState(617)
			p.ExtendedAttributeInner()
		}

	case WebIDLParserT__2:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(619)
			p.Match(WebIDLParserT__2)
		}
		{
			p.SetState(620)
			p.ExtendedAttributeInner()
		}
		{
			p.SetState(621)
			p.Match(WebIDLParserT__3)
		}
		{
			p.SetState(622)
			p.ExtendedAttributeInner()
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__4, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__12, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__25, WebIDLParserT__26, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__37, WebIDLParserT__38, WebIDLParserT__39, WebIDLParserT__40, WebIDLParserT__41, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__44, WebIDLParserT__45, WebIDLParserT__46, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserINTEGER_WEBIDL, WebIDLParserFLOAT_WEBIDL, WebIDLParserIDENTIFIER_WEBIDL, WebIDLParserSTRING_WEBIDL, WebIDLParserOTHER_WEBIDL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(624)
			p.OtherOrComma()
		}
		{
			p.SetState(625)
			p.ExtendedAttributeInner()
		}

	case WebIDLParserT__3, WebIDLParserT__11, WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 5)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOtherContext is an interface to support dynamic dispatch.
type IOtherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOtherContext differentiates from other interfaces.
	IsOtherContext()
}

type OtherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOtherContext() *OtherContext {
	var p = new(OtherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_other
	return p
}

func (*OtherContext) IsOtherContext() {}

func NewOtherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OtherContext {
	var p = new(OtherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_other

	return p
}

func (s *OtherContext) GetParser() antlr.Parser { return s.parser }

func (s *OtherContext) INTEGER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserINTEGER_WEBIDL, 0)
}

func (s *OtherContext) FLOAT_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserFLOAT_WEBIDL, 0)
}

func (s *OtherContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *OtherContext) STRING_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserSTRING_WEBIDL, 0)
}

func (s *OtherContext) OTHER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserOTHER_WEBIDL, 0)
}

func (s *OtherContext) ArgumentNameKeyword() IArgumentNameKeywordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentNameKeywordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentNameKeywordContext)
}

func (s *OtherContext) BufferRelatedType() IBufferRelatedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBufferRelatedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBufferRelatedTypeContext)
}

func (s *OtherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OtherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OtherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOther(s)
	}
}

func (s *OtherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOther(s)
	}
}

func (p *WebIDLParser) Other() (localctx IOtherContext) {
	localctx = NewOtherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, WebIDLParserRULE_other)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(671)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserINTEGER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(630)
			p.Match(WebIDLParserINTEGER_WEBIDL)
		}

	case WebIDLParserFLOAT_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(631)
			p.Match(WebIDLParserFLOAT_WEBIDL)
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(632)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}

	case WebIDLParserSTRING_WEBIDL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(633)
			p.Match(WebIDLParserSTRING_WEBIDL)
		}

	case WebIDLParserOTHER_WEBIDL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(634)
			p.Match(WebIDLParserOTHER_WEBIDL)
		}

	case WebIDLParserT__44:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(635)
			p.Match(WebIDLParserT__44)
		}

	case WebIDLParserT__24:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(636)
			p.Match(WebIDLParserT__24)
		}

	case WebIDLParserT__45:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(637)
			p.Match(WebIDLParserT__45)
		}

	case WebIDLParserT__38:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(638)
			p.Match(WebIDLParserT__38)
		}

	case WebIDLParserT__12:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(639)
			p.Match(WebIDLParserT__12)
		}

	case WebIDLParserT__4:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(640)
			p.Match(WebIDLParserT__4)
		}

	case WebIDLParserT__40:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(641)
			p.Match(WebIDLParserT__40)
		}

	case WebIDLParserT__9:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(642)
			p.Match(WebIDLParserT__9)
		}

	case WebIDLParserT__41:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(643)
			p.Match(WebIDLParserT__41)
		}

	case WebIDLParserT__46:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(644)
			p.Match(WebIDLParserT__46)
		}

	case WebIDLParserT__47:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(645)
			p.Match(WebIDLParserT__47)
		}

	case WebIDLParserT__48:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(646)
			p.Match(WebIDLParserT__48)
		}

	case WebIDLParserT__49:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(647)
			p.Match(WebIDLParserT__49)
		}

	case WebIDLParserT__25:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(648)
			p.Match(WebIDLParserT__25)
		}

	case WebIDLParserT__26:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(649)
			p.Match(WebIDLParserT__26)
		}

	case WebIDLParserT__50:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(650)
			p.Match(WebIDLParserT__50)
		}

	case WebIDLParserT__51:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(651)
			p.Match(WebIDLParserT__51)
		}

	case WebIDLParserT__52:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(652)
			p.Match(WebIDLParserT__52)
		}

	case WebIDLParserT__53:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(653)
			p.Match(WebIDLParserT__53)
		}

	case WebIDLParserT__54:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(654)
			p.Match(WebIDLParserT__54)
		}

	case WebIDLParserT__55:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(655)
			p.Match(WebIDLParserT__55)
		}

	case WebIDLParserT__23:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(656)
			p.Match(WebIDLParserT__23)
		}

	case WebIDLParserT__56:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(657)
			p.Match(WebIDLParserT__56)
		}

	case WebIDLParserT__57:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(658)
			p.Match(WebIDLParserT__57)
		}

	case WebIDLParserT__21:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(659)
			p.Match(WebIDLParserT__21)
		}

	case WebIDLParserT__58:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(660)
			p.Match(WebIDLParserT__58)
		}

	case WebIDLParserT__59:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(661)
			p.Match(WebIDLParserT__59)
		}

	case WebIDLParserT__60:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(662)
			p.Match(WebIDLParserT__60)
		}

	case WebIDLParserT__37:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(663)
			p.Match(WebIDLParserT__37)
		}

	case WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(664)
			p.Match(WebIDLParserT__61)
		}

	case WebIDLParserT__62:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(665)
			p.Match(WebIDLParserT__62)
		}

	case WebIDLParserT__22:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(666)
			p.Match(WebIDLParserT__22)
		}

	case WebIDLParserT__63:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(667)
			p.Match(WebIDLParserT__63)
		}

	case WebIDLParserT__64:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(668)
			p.Match(WebIDLParserT__64)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__14, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__39, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__65:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(669)
			p.ArgumentNameKeyword()
		}

	case WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(670)
			p.BufferRelatedType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentNameKeywordContext is an interface to support dynamic dispatch.
type IArgumentNameKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentNameKeywordContext differentiates from other interfaces.
	IsArgumentNameKeywordContext()
}

type ArgumentNameKeywordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentNameKeywordContext() *ArgumentNameKeywordContext {
	var p = new(ArgumentNameKeywordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_argumentNameKeyword
	return p
}

func (*ArgumentNameKeywordContext) IsArgumentNameKeywordContext() {}

func NewArgumentNameKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentNameKeywordContext {
	var p = new(ArgumentNameKeywordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_argumentNameKeyword

	return p
}

func (s *ArgumentNameKeywordContext) GetParser() antlr.Parser { return s.parser }
func (s *ArgumentNameKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentNameKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentNameKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterArgumentNameKeyword(s)
	}
}

func (s *ArgumentNameKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitArgumentNameKeyword(s)
	}
}

func (p *WebIDLParser) ArgumentNameKeyword() (localctx IArgumentNameKeywordContext) {
	localctx = NewArgumentNameKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, WebIDLParserRULE_argumentNameKeyword)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<WebIDLParserT__0)|(1<<WebIDLParserT__1)|(1<<WebIDLParserT__6)|(1<<WebIDLParserT__7)|(1<<WebIDLParserT__8)|(1<<WebIDLParserT__14)|(1<<WebIDLParserT__18)|(1<<WebIDLParserT__19)|(1<<WebIDLParserT__20)|(1<<WebIDLParserT__27)|(1<<WebIDLParserT__28)|(1<<WebIDLParserT__29)|(1<<WebIDLParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(WebIDLParserT__31-32))|(1<<(WebIDLParserT__33-32))|(1<<(WebIDLParserT__34-32))|(1<<(WebIDLParserT__35-32))|(1<<(WebIDLParserT__36-32))|(1<<(WebIDLParserT__39-32))|(1<<(WebIDLParserT__42-32))|(1<<(WebIDLParserT__43-32)))) != 0) || _la == WebIDLParserT__65) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOtherOrCommaContext is an interface to support dynamic dispatch.
type IOtherOrCommaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOtherOrCommaContext differentiates from other interfaces.
	IsOtherOrCommaContext()
}

type OtherOrCommaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOtherOrCommaContext() *OtherOrCommaContext {
	var p = new(OtherOrCommaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_otherOrComma
	return p
}

func (*OtherOrCommaContext) IsOtherOrCommaContext() {}

func NewOtherOrCommaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OtherOrCommaContext {
	var p = new(OtherOrCommaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_otherOrComma

	return p
}

func (s *OtherOrCommaContext) GetParser() antlr.Parser { return s.parser }

func (s *OtherOrCommaContext) Other() IOtherContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOtherContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOtherContext)
}

func (s *OtherOrCommaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OtherOrCommaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OtherOrCommaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOtherOrComma(s)
	}
}

func (s *OtherOrCommaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOtherOrComma(s)
	}
}

func (p *WebIDLParser) OtherOrComma() (localctx IOtherOrCommaContext) {
	localctx = NewOtherOrCommaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, WebIDLParserRULE_otherOrComma)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(677)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__4, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__9, WebIDLParserT__12, WebIDLParserT__14, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__21, WebIDLParserT__22, WebIDLParserT__23, WebIDLParserT__24, WebIDLParserT__25, WebIDLParserT__26, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__37, WebIDLParserT__38, WebIDLParserT__39, WebIDLParserT__40, WebIDLParserT__41, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__44, WebIDLParserT__45, WebIDLParserT__46, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__60, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__64, WebIDLParserT__65, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserINTEGER_WEBIDL, WebIDLParserFLOAT_WEBIDL, WebIDLParserIDENTIFIER_WEBIDL, WebIDLParserSTRING_WEBIDL, WebIDLParserOTHER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(675)
			p.Other()
		}

	case WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(676)
			p.Match(WebIDLParserT__15)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_type
	return p
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) SingleType() ISingleTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleTypeContext)
}

func (s *TypeContext) UnionType() IUnionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionTypeContext)
}

func (s *TypeContext) Null_() INull_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_Context)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitType(s)
	}
}

func (p *WebIDLParser) Type() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, WebIDLParserRULE_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(683)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(679)
			p.SingleType()
		}

	case WebIDLParserT__16:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(680)
			p.UnionType()
		}
		{
			p.SetState(681)
			p.Null_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISingleTypeContext is an interface to support dynamic dispatch.
type ISingleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleTypeContext differentiates from other interfaces.
	IsSingleTypeContext()
}

type SingleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTypeContext() *SingleTypeContext {
	var p = new(SingleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_singleType
	return p
}

func (*SingleTypeContext) IsSingleTypeContext() {}

func NewSingleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTypeContext {
	var p = new(SingleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_singleType

	return p
}

func (s *SingleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTypeContext) NonAnyType() INonAnyTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonAnyTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonAnyTypeContext)
}

func (s *SingleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterSingleType(s)
	}
}

func (s *SingleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitSingleType(s)
	}
}

func (p *WebIDLParser) SingleType() (localctx ISingleTypeContext) {
	localctx = NewSingleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, WebIDLParserRULE_singleType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(687)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(685)
			p.NonAnyType()
		}

	case WebIDLParserT__52:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(686)
			p.Match(WebIDLParserT__52)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionTypeContext is an interface to support dynamic dispatch.
type IUnionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionTypeContext differentiates from other interfaces.
	IsUnionTypeContext()
}

type UnionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionTypeContext() *UnionTypeContext {
	var p = new(UnionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unionType
	return p
}

func (*UnionTypeContext) IsUnionTypeContext() {}

func NewUnionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionTypeContext {
	var p = new(UnionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unionType

	return p
}

func (s *UnionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionTypeContext) AllUnionMemberType() []IUnionMemberTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionMemberTypeContext)(nil)).Elem())
	var tst = make([]IUnionMemberTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionMemberTypeContext)
		}
	}

	return tst
}

func (s *UnionTypeContext) UnionMemberType(i int) IUnionMemberTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMemberTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionMemberTypeContext)
}

func (s *UnionTypeContext) UnionMemberTypes() IUnionMemberTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMemberTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionMemberTypesContext)
}

func (s *UnionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnionType(s)
	}
}

func (s *UnionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnionType(s)
	}
}

func (p *WebIDLParser) UnionType() (localctx IUnionTypeContext) {
	localctx = NewUnionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, WebIDLParserRULE_unionType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(689)
		p.Match(WebIDLParserT__16)
	}
	{
		p.SetState(690)
		p.UnionMemberType()
	}
	{
		p.SetState(691)
		p.Match(WebIDLParserT__60)
	}
	{
		p.SetState(692)
		p.UnionMemberType()
	}
	{
		p.SetState(693)
		p.UnionMemberTypes()
	}
	{
		p.SetState(694)
		p.Match(WebIDLParserT__17)
	}

	return localctx
}

// IUnionMemberTypeContext is an interface to support dynamic dispatch.
type IUnionMemberTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionMemberTypeContext differentiates from other interfaces.
	IsUnionMemberTypeContext()
}

type UnionMemberTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMemberTypeContext() *UnionMemberTypeContext {
	var p = new(UnionMemberTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unionMemberType
	return p
}

func (*UnionMemberTypeContext) IsUnionMemberTypeContext() {}

func NewUnionMemberTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMemberTypeContext {
	var p = new(UnionMemberTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unionMemberType

	return p
}

func (s *UnionMemberTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMemberTypeContext) NonAnyType() INonAnyTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonAnyTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonAnyTypeContext)
}

func (s *UnionMemberTypeContext) UnionType() IUnionTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionTypeContext)
}

func (s *UnionMemberTypeContext) Null_() INull_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_Context)
}

func (s *UnionMemberTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMemberTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMemberTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnionMemberType(s)
	}
}

func (s *UnionMemberTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnionMemberType(s)
	}
}

func (p *WebIDLParser) UnionMemberType() (localctx IUnionMemberTypeContext) {
	localctx = NewUnionMemberTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, WebIDLParserRULE_unionMemberType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(700)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(696)
			p.NonAnyType()
		}

	case WebIDLParserT__16:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(697)
			p.UnionType()
		}
		{
			p.SetState(698)
			p.Null_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionMemberTypesContext is an interface to support dynamic dispatch.
type IUnionMemberTypesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnionMemberTypesContext differentiates from other interfaces.
	IsUnionMemberTypesContext()
}

type UnionMemberTypesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionMemberTypesContext() *UnionMemberTypesContext {
	var p = new(UnionMemberTypesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unionMemberTypes
	return p
}

func (*UnionMemberTypesContext) IsUnionMemberTypesContext() {}

func NewUnionMemberTypesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionMemberTypesContext {
	var p = new(UnionMemberTypesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unionMemberTypes

	return p
}

func (s *UnionMemberTypesContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionMemberTypesContext) UnionMemberType() IUnionMemberTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMemberTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionMemberTypeContext)
}

func (s *UnionMemberTypesContext) UnionMemberTypes() IUnionMemberTypesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionMemberTypesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionMemberTypesContext)
}

func (s *UnionMemberTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionMemberTypesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionMemberTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnionMemberTypes(s)
	}
}

func (s *UnionMemberTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnionMemberTypes(s)
	}
}

func (p *WebIDLParser) UnionMemberTypes() (localctx IUnionMemberTypesContext) {
	localctx = NewUnionMemberTypesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, WebIDLParserRULE_unionMemberTypes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(707)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__60:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(702)
			p.Match(WebIDLParserT__60)
		}
		{
			p.SetState(703)
			p.UnionMemberType()
		}
		{
			p.SetState(704)
			p.UnionMemberTypes()
		}

	case WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonAnyTypeContext is an interface to support dynamic dispatch.
type INonAnyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonAnyTypeContext differentiates from other interfaces.
	IsNonAnyTypeContext()
}

type NonAnyTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonAnyTypeContext() *NonAnyTypeContext {
	var p = new(NonAnyTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_nonAnyType
	return p
}

func (*NonAnyTypeContext) IsNonAnyTypeContext() {}

func NewNonAnyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonAnyTypeContext {
	var p = new(NonAnyTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_nonAnyType

	return p
}

func (s *NonAnyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NonAnyTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *NonAnyTypeContext) Null_() INull_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_Context)
}

func (s *NonAnyTypeContext) PromiseType() IPromiseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPromiseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPromiseTypeContext)
}

func (s *NonAnyTypeContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *NonAnyTypeContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *NonAnyTypeContext) BufferRelatedType() IBufferRelatedTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBufferRelatedTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBufferRelatedTypeContext)
}

func (s *NonAnyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonAnyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonAnyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterNonAnyType(s)
	}
}

func (s *NonAnyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitNonAnyType(s)
	}
}

func (p *WebIDLParser) NonAnyType() (localctx INonAnyTypeContext) {
	localctx = NewNonAnyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, WebIDLParserRULE_nonAnyType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(744)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__59, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(709)
			p.PrimitiveType()
		}
		{
			p.SetState(710)
			p.Null_()
		}

	case WebIDLParserT__78:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(712)
			p.PromiseType()
		}
		{
			p.SetState(713)
			p.Null_()
		}

	case WebIDLParserT__47:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(715)
			p.Match(WebIDLParserT__47)
		}
		{
			p.SetState(716)
			p.Null_()
		}

	case WebIDLParserT__48:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(717)
			p.Match(WebIDLParserT__48)
		}
		{
			p.SetState(718)
			p.Null_()
		}

	case WebIDLParserT__51:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(719)
			p.Match(WebIDLParserT__51)
		}
		{
			p.SetState(720)
			p.Null_()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(721)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(722)
			p.Null_()
		}

	case WebIDLParserT__61:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(723)
			p.Match(WebIDLParserT__61)
		}
		{
			p.SetState(724)
			p.Match(WebIDLParserT__40)
		}
		{
			p.SetState(725)
			p.Type()
		}
		{
			p.SetState(726)
			p.Match(WebIDLParserT__41)
		}
		{
			p.SetState(727)
			p.Null_()
		}

	case WebIDLParserT__58:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(729)
			p.Match(WebIDLParserT__58)
		}
		{
			p.SetState(730)
			p.Null_()
		}

	case WebIDLParserT__50:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(731)
			p.Match(WebIDLParserT__50)
		}
		{
			p.SetState(732)
			p.Null_()
		}

	case WebIDLParserT__66:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(733)
			p.Match(WebIDLParserT__66)
		}
		{
			p.SetState(734)
			p.Null_()
		}

	case WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(735)
			p.BufferRelatedType()
		}
		{
			p.SetState(736)
			p.Null_()
		}

	case WebIDLParserT__49:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(738)
			p.Match(WebIDLParserT__49)
		}
		{
			p.SetState(739)
			p.Match(WebIDLParserT__40)
		}
		{
			p.SetState(740)
			p.Type()
		}
		{
			p.SetState(741)
			p.Match(WebIDLParserT__41)
		}
		{
			p.SetState(742)
			p.Null_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBufferRelatedTypeContext is an interface to support dynamic dispatch.
type IBufferRelatedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBufferRelatedTypeContext differentiates from other interfaces.
	IsBufferRelatedTypeContext()
}

type BufferRelatedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBufferRelatedTypeContext() *BufferRelatedTypeContext {
	var p = new(BufferRelatedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_bufferRelatedType
	return p
}

func (*BufferRelatedTypeContext) IsBufferRelatedTypeContext() {}

func NewBufferRelatedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BufferRelatedTypeContext {
	var p = new(BufferRelatedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_bufferRelatedType

	return p
}

func (s *BufferRelatedTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *BufferRelatedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BufferRelatedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BufferRelatedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterBufferRelatedType(s)
	}
}

func (s *BufferRelatedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitBufferRelatedType(s)
	}
}

func (p *WebIDLParser) BufferRelatedType() (localctx IBufferRelatedTypeContext) {
	localctx = NewBufferRelatedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, WebIDLParserRULE_bufferRelatedType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(WebIDLParserT__67-68))|(1<<(WebIDLParserT__68-68))|(1<<(WebIDLParserT__69-68))|(1<<(WebIDLParserT__70-68))|(1<<(WebIDLParserT__71-68))|(1<<(WebIDLParserT__72-68))|(1<<(WebIDLParserT__73-68))|(1<<(WebIDLParserT__74-68))|(1<<(WebIDLParserT__75-68))|(1<<(WebIDLParserT__76-68))|(1<<(WebIDLParserT__77-68)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IConstTypeContext is an interface to support dynamic dispatch.
type IConstTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstTypeContext differentiates from other interfaces.
	IsConstTypeContext()
}

type ConstTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstTypeContext() *ConstTypeContext {
	var p = new(ConstTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_constType
	return p
}

func (*ConstTypeContext) IsConstTypeContext() {}

func NewConstTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstTypeContext {
	var p = new(ConstTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_constType

	return p
}

func (s *ConstTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ConstTypeContext) Null_() INull_Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INull_Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INull_Context)
}

func (s *ConstTypeContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ConstTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterConstType(s)
	}
}

func (s *ConstTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitConstType(s)
	}
}

func (p *WebIDLParser) ConstType() (localctx IConstTypeContext) {
	localctx = NewConstTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, WebIDLParserRULE_constType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(753)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__59, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(748)
			p.PrimitiveType()
		}
		{
			p.SetState(749)
			p.Null_()
		}

	case WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(751)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(752)
			p.Null_()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) UnsignedIntegerType() IUnsignedIntegerTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsignedIntegerTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsignedIntegerTypeContext)
}

func (s *PrimitiveTypeContext) UnrestrictedFloatType() IUnrestrictedFloatTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnrestrictedFloatTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnrestrictedFloatTypeContext)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *WebIDLParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, WebIDLParserRULE_primitiveType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(760)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__57, WebIDLParserT__62, WebIDLParserT__63:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.UnsignedIntegerType()
		}

	case WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__65:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.UnrestrictedFloatType()
		}

	case WebIDLParserT__53:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(757)
			p.Match(WebIDLParserT__53)
		}

	case WebIDLParserT__54:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(758)
			p.Match(WebIDLParserT__54)
		}

	case WebIDLParserT__59:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(759)
			p.Match(WebIDLParserT__59)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnrestrictedFloatTypeContext is an interface to support dynamic dispatch.
type IUnrestrictedFloatTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnrestrictedFloatTypeContext differentiates from other interfaces.
	IsUnrestrictedFloatTypeContext()
}

type UnrestrictedFloatTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnrestrictedFloatTypeContext() *UnrestrictedFloatTypeContext {
	var p = new(UnrestrictedFloatTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unrestrictedFloatType
	return p
}

func (*UnrestrictedFloatTypeContext) IsUnrestrictedFloatTypeContext() {}

func NewUnrestrictedFloatTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnrestrictedFloatTypeContext {
	var p = new(UnrestrictedFloatTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unrestrictedFloatType

	return p
}

func (s *UnrestrictedFloatTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnrestrictedFloatTypeContext) FloatType() IFloatTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloatTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloatTypeContext)
}

func (s *UnrestrictedFloatTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnrestrictedFloatTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnrestrictedFloatTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnrestrictedFloatType(s)
	}
}

func (s *UnrestrictedFloatTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnrestrictedFloatType(s)
	}
}

func (p *WebIDLParser) UnrestrictedFloatType() (localctx IUnrestrictedFloatTypeContext) {
	localctx = NewUnrestrictedFloatTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, WebIDLParserRULE_unrestrictedFloatType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(765)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__65:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(762)
			p.Match(WebIDLParserT__65)
		}
		{
			p.SetState(763)
			p.FloatType()
		}

	case WebIDLParserT__55, WebIDLParserT__56:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(764)
			p.FloatType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFloatTypeContext is an interface to support dynamic dispatch.
type IFloatTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloatTypeContext differentiates from other interfaces.
	IsFloatTypeContext()
}

type FloatTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatTypeContext() *FloatTypeContext {
	var p = new(FloatTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_floatType
	return p
}

func (*FloatTypeContext) IsFloatTypeContext() {}

func NewFloatTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatTypeContext {
	var p = new(FloatTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_floatType

	return p
}

func (s *FloatTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *FloatTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterFloatType(s)
	}
}

func (s *FloatTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitFloatType(s)
	}
}

func (p *WebIDLParser) FloatType() (localctx IFloatTypeContext) {
	localctx = NewFloatTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, WebIDLParserRULE_floatType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		_la = p.GetTokenStream().LA(1)

		if !(_la == WebIDLParserT__55 || _la == WebIDLParserT__56) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnsignedIntegerTypeContext is an interface to support dynamic dispatch.
type IUnsignedIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsignedIntegerTypeContext differentiates from other interfaces.
	IsUnsignedIntegerTypeContext()
}

type UnsignedIntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsignedIntegerTypeContext() *UnsignedIntegerTypeContext {
	var p = new(UnsignedIntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_unsignedIntegerType
	return p
}

func (*UnsignedIntegerTypeContext) IsUnsignedIntegerTypeContext() {}

func NewUnsignedIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsignedIntegerTypeContext {
	var p = new(UnsignedIntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_unsignedIntegerType

	return p
}

func (s *UnsignedIntegerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsignedIntegerTypeContext) IntegerType() IIntegerTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegerTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegerTypeContext)
}

func (s *UnsignedIntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsignedIntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsignedIntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterUnsignedIntegerType(s)
	}
}

func (s *UnsignedIntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitUnsignedIntegerType(s)
	}
}

func (p *WebIDLParser) UnsignedIntegerType() (localctx IUnsignedIntegerTypeContext) {
	localctx = NewUnsignedIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, WebIDLParserRULE_unsignedIntegerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(772)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__63:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(769)
			p.Match(WebIDLParserT__63)
		}
		{
			p.SetState(770)
			p.IntegerType()
		}

	case WebIDLParserT__57, WebIDLParserT__62:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(771)
			p.IntegerType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerTypeContext is an interface to support dynamic dispatch.
type IIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerTypeContext differentiates from other interfaces.
	IsIntegerTypeContext()
}

type IntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerTypeContext() *IntegerTypeContext {
	var p = new(IntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_integerType
	return p
}

func (*IntegerTypeContext) IsIntegerTypeContext() {}

func NewIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerTypeContext {
	var p = new(IntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_integerType

	return p
}

func (s *IntegerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerTypeContext) OptionalLong() IOptionalLongContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOptionalLongContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOptionalLongContext)
}

func (s *IntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIntegerType(s)
	}
}

func (s *IntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIntegerType(s)
	}
}

func (p *WebIDLParser) IntegerType() (localctx IIntegerTypeContext) {
	localctx = NewIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, WebIDLParserRULE_integerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(777)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__62:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(774)
			p.Match(WebIDLParserT__62)
		}

	case WebIDLParserT__57:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(775)
			p.Match(WebIDLParserT__57)
		}
		{
			p.SetState(776)
			p.OptionalLong()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOptionalLongContext is an interface to support dynamic dispatch.
type IOptionalLongContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOptionalLongContext differentiates from other interfaces.
	IsOptionalLongContext()
}

type OptionalLongContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionalLongContext() *OptionalLongContext {
	var p = new(OptionalLongContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_optionalLong
	return p
}

func (*OptionalLongContext) IsOptionalLongContext() {}

func NewOptionalLongContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionalLongContext {
	var p = new(OptionalLongContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_optionalLong

	return p
}

func (s *OptionalLongContext) GetParser() antlr.Parser { return s.parser }
func (s *OptionalLongContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionalLongContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionalLongContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterOptionalLong(s)
	}
}

func (s *OptionalLongContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitOptionalLong(s)
	}
}

func (p *WebIDLParser) OptionalLong() (localctx IOptionalLongContext) {
	localctx = NewOptionalLongContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, WebIDLParserRULE_optionalLong)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(781)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__57:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(779)
			p.Match(WebIDLParserT__57)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__38, WebIDLParserT__39, WebIDLParserT__41, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__46, WebIDLParserT__60, WebIDLParserT__65, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPromiseTypeContext is an interface to support dynamic dispatch.
type IPromiseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPromiseTypeContext differentiates from other interfaces.
	IsPromiseTypeContext()
}

type PromiseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPromiseTypeContext() *PromiseTypeContext {
	var p = new(PromiseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_promiseType
	return p
}

func (*PromiseTypeContext) IsPromiseTypeContext() {}

func NewPromiseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PromiseTypeContext {
	var p = new(PromiseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_promiseType

	return p
}

func (s *PromiseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PromiseTypeContext) ReturnType() IReturnTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnTypeContext)
}

func (s *PromiseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PromiseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PromiseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterPromiseType(s)
	}
}

func (s *PromiseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitPromiseType(s)
	}
}

func (p *WebIDLParser) PromiseType() (localctx IPromiseTypeContext) {
	localctx = NewPromiseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, WebIDLParserRULE_promiseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Match(WebIDLParserT__78)
	}
	{
		p.SetState(784)
		p.Match(WebIDLParserT__40)
	}
	{
		p.SetState(785)
		p.ReturnType()
	}
	{
		p.SetState(786)
		p.Match(WebIDLParserT__41)
	}

	return localctx
}

// INull_Context is an interface to support dynamic dispatch.
type INull_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNull_Context differentiates from other interfaces.
	IsNull_Context()
}

type Null_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNull_Context() *Null_Context {
	var p = new(Null_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_null_
	return p
}

func (*Null_Context) IsNull_Context() {}

func NewNull_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Null_Context {
	var p = new(Null_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_null_

	return p
}

func (s *Null_Context) GetParser() antlr.Parser { return s.parser }
func (s *Null_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Null_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Null_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterNull_(s)
	}
}

func (s *Null_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitNull_(s)
	}
}

func (p *WebIDLParser) Null_() (localctx INull_Context) {
	localctx = NewNull_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, WebIDLParserRULE_null_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(790)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__46:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(788)
			p.Match(WebIDLParserT__46)
		}

	case WebIDLParserT__0, WebIDLParserT__1, WebIDLParserT__6, WebIDLParserT__7, WebIDLParserT__8, WebIDLParserT__14, WebIDLParserT__15, WebIDLParserT__16, WebIDLParserT__17, WebIDLParserT__18, WebIDLParserT__19, WebIDLParserT__20, WebIDLParserT__27, WebIDLParserT__28, WebIDLParserT__29, WebIDLParserT__30, WebIDLParserT__31, WebIDLParserT__33, WebIDLParserT__34, WebIDLParserT__35, WebIDLParserT__36, WebIDLParserT__38, WebIDLParserT__39, WebIDLParserT__41, WebIDLParserT__42, WebIDLParserT__43, WebIDLParserT__60, WebIDLParserT__65, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReturnTypeContext is an interface to support dynamic dispatch.
type IReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnTypeContext differentiates from other interfaces.
	IsReturnTypeContext()
}

type ReturnTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnTypeContext() *ReturnTypeContext {
	var p = new(ReturnTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_returnType
	return p
}

func (*ReturnTypeContext) IsReturnTypeContext() {}

func NewReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnTypeContext {
	var p = new(ReturnTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_returnType

	return p
}

func (s *ReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnTypeContext) Type() ITypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterReturnType(s)
	}
}

func (s *ReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitReturnType(s)
	}
}

func (p *WebIDLParser) ReturnType() (localctx IReturnTypeContext) {
	localctx = NewReturnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, WebIDLParserRULE_returnType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(794)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__16, WebIDLParserT__47, WebIDLParserT__48, WebIDLParserT__49, WebIDLParserT__50, WebIDLParserT__51, WebIDLParserT__52, WebIDLParserT__53, WebIDLParserT__54, WebIDLParserT__55, WebIDLParserT__56, WebIDLParserT__57, WebIDLParserT__58, WebIDLParserT__59, WebIDLParserT__61, WebIDLParserT__62, WebIDLParserT__63, WebIDLParserT__65, WebIDLParserT__66, WebIDLParserT__67, WebIDLParserT__68, WebIDLParserT__69, WebIDLParserT__70, WebIDLParserT__71, WebIDLParserT__72, WebIDLParserT__73, WebIDLParserT__74, WebIDLParserT__75, WebIDLParserT__76, WebIDLParserT__77, WebIDLParserT__78, WebIDLParserIDENTIFIER_WEBIDL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(792)
			p.Type()
		}

	case WebIDLParserT__64:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(793)
			p.Match(WebIDLParserT__64)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_identifierList
	return p
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *IdentifierListContext) Identifiers() IIdentifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifiersContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *WebIDLParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, WebIDLParserRULE_identifierList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(796)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(797)
		p.Identifiers()
	}

	return localctx
}

// IIdentifiersContext is an interface to support dynamic dispatch.
type IIdentifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifiersContext differentiates from other interfaces.
	IsIdentifiersContext()
}

type IdentifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifiersContext() *IdentifiersContext {
	var p = new(IdentifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_identifiers
	return p
}

func (*IdentifiersContext) IsIdentifiersContext() {}

func NewIdentifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifiersContext {
	var p = new(IdentifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_identifiers

	return p
}

func (s *IdentifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifiersContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *IdentifiersContext) Identifiers() IIdentifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifiersContext)
}

func (s *IdentifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterIdentifiers(s)
	}
}

func (s *IdentifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitIdentifiers(s)
	}
}

func (p *WebIDLParser) Identifiers() (localctx IIdentifiersContext) {
	localctx = NewIdentifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, WebIDLParserRULE_identifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(803)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case WebIDLParserT__15:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(799)
			p.Match(WebIDLParserT__15)
		}
		{
			p.SetState(800)
			p.Match(WebIDLParserIDENTIFIER_WEBIDL)
		}
		{
			p.SetState(801)
			p.Identifiers()
		}

	case WebIDLParserT__3, WebIDLParserT__11, WebIDLParserT__17:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExtendedAttributeNoArgsContext is an interface to support dynamic dispatch.
type IExtendedAttributeNoArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeNoArgsContext differentiates from other interfaces.
	IsExtendedAttributeNoArgsContext()
}

type ExtendedAttributeNoArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeNoArgsContext() *ExtendedAttributeNoArgsContext {
	var p = new(ExtendedAttributeNoArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeNoArgs
	return p
}

func (*ExtendedAttributeNoArgsContext) IsExtendedAttributeNoArgsContext() {}

func NewExtendedAttributeNoArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeNoArgsContext {
	var p = new(ExtendedAttributeNoArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeNoArgs

	return p
}

func (s *ExtendedAttributeNoArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeNoArgsContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtendedAttributeNoArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeNoArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeNoArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeNoArgs(s)
	}
}

func (s *ExtendedAttributeNoArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeNoArgs(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeNoArgs() (localctx IExtendedAttributeNoArgsContext) {
	localctx = NewExtendedAttributeNoArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, WebIDLParserRULE_extendedAttributeNoArgs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}

	return localctx
}

// IExtendedAttributeArgListContext is an interface to support dynamic dispatch.
type IExtendedAttributeArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeArgListContext differentiates from other interfaces.
	IsExtendedAttributeArgListContext()
}

type ExtendedAttributeArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeArgListContext() *ExtendedAttributeArgListContext {
	var p = new(ExtendedAttributeArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeArgList
	return p
}

func (*ExtendedAttributeArgListContext) IsExtendedAttributeArgListContext() {}

func NewExtendedAttributeArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeArgListContext {
	var p = new(ExtendedAttributeArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeArgList

	return p
}

func (s *ExtendedAttributeArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeArgListContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtendedAttributeArgListContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ExtendedAttributeArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeArgList(s)
	}
}

func (s *ExtendedAttributeArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeArgList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeArgList() (localctx IExtendedAttributeArgListContext) {
	localctx = NewExtendedAttributeArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, WebIDLParserRULE_extendedAttributeArgList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(807)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(808)
		p.Match(WebIDLParserT__16)
	}
	{
		p.SetState(809)
		p.ArgumentList()
	}
	{
		p.SetState(810)
		p.Match(WebIDLParserT__17)
	}

	return localctx
}

// IExtendedAttributeIdentContext is an interface to support dynamic dispatch.
type IExtendedAttributeIdentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeIdentContext differentiates from other interfaces.
	IsExtendedAttributeIdentContext()
}

type ExtendedAttributeIdentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeIdentContext() *ExtendedAttributeIdentContext {
	var p = new(ExtendedAttributeIdentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeIdent
	return p
}

func (*ExtendedAttributeIdentContext) IsExtendedAttributeIdentContext() {}

func NewExtendedAttributeIdentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeIdentContext {
	var p = new(ExtendedAttributeIdentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeIdent

	return p
}

func (s *ExtendedAttributeIdentContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeIdentContext) AllIDENTIFIER_WEBIDL() []antlr.TerminalNode {
	return s.GetTokens(WebIDLParserIDENTIFIER_WEBIDL)
}

func (s *ExtendedAttributeIdentContext) IDENTIFIER_WEBIDL(i int) antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, i)
}

func (s *ExtendedAttributeIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeIdentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeIdentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeIdent(s)
	}
}

func (s *ExtendedAttributeIdentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeIdent(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeIdent() (localctx IExtendedAttributeIdentContext) {
	localctx = NewExtendedAttributeIdentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, WebIDLParserRULE_extendedAttributeIdent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(813)
		p.Match(WebIDLParserT__9)
	}
	{
		p.SetState(814)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}

	return localctx
}

// IExtendedAttributeIdentListContext is an interface to support dynamic dispatch.
type IExtendedAttributeIdentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeIdentListContext differentiates from other interfaces.
	IsExtendedAttributeIdentListContext()
}

type ExtendedAttributeIdentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeIdentListContext() *ExtendedAttributeIdentListContext {
	var p = new(ExtendedAttributeIdentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeIdentList
	return p
}

func (*ExtendedAttributeIdentListContext) IsExtendedAttributeIdentListContext() {}

func NewExtendedAttributeIdentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeIdentListContext {
	var p = new(ExtendedAttributeIdentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeIdentList

	return p
}

func (s *ExtendedAttributeIdentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeIdentListContext) IDENTIFIER_WEBIDL() antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, 0)
}

func (s *ExtendedAttributeIdentListContext) IdentifierList() IIdentifierListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ExtendedAttributeIdentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeIdentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeIdentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeIdentList(s)
	}
}

func (s *ExtendedAttributeIdentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeIdentList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeIdentList() (localctx IExtendedAttributeIdentListContext) {
	localctx = NewExtendedAttributeIdentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, WebIDLParserRULE_extendedAttributeIdentList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(817)
		p.Match(WebIDLParserT__9)
	}
	{
		p.SetState(818)
		p.Match(WebIDLParserT__16)
	}
	{
		p.SetState(819)
		p.IdentifierList()
	}
	{
		p.SetState(820)
		p.Match(WebIDLParserT__17)
	}

	return localctx
}

// IExtendedAttributeNamedArgListContext is an interface to support dynamic dispatch.
type IExtendedAttributeNamedArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExtendedAttributeNamedArgListContext differentiates from other interfaces.
	IsExtendedAttributeNamedArgListContext()
}

type ExtendedAttributeNamedArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendedAttributeNamedArgListContext() *ExtendedAttributeNamedArgListContext {
	var p = new(ExtendedAttributeNamedArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = WebIDLParserRULE_extendedAttributeNamedArgList
	return p
}

func (*ExtendedAttributeNamedArgListContext) IsExtendedAttributeNamedArgListContext() {}

func NewExtendedAttributeNamedArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendedAttributeNamedArgListContext {
	var p = new(ExtendedAttributeNamedArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = WebIDLParserRULE_extendedAttributeNamedArgList

	return p
}

func (s *ExtendedAttributeNamedArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendedAttributeNamedArgListContext) AllIDENTIFIER_WEBIDL() []antlr.TerminalNode {
	return s.GetTokens(WebIDLParserIDENTIFIER_WEBIDL)
}

func (s *ExtendedAttributeNamedArgListContext) IDENTIFIER_WEBIDL(i int) antlr.TerminalNode {
	return s.GetToken(WebIDLParserIDENTIFIER_WEBIDL, i)
}

func (s *ExtendedAttributeNamedArgListContext) ArgumentList() IArgumentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ExtendedAttributeNamedArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendedAttributeNamedArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendedAttributeNamedArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.EnterExtendedAttributeNamedArgList(s)
	}
}

func (s *ExtendedAttributeNamedArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(WebIDLListener); ok {
		listenerT.ExitExtendedAttributeNamedArgList(s)
	}
}

func (p *WebIDLParser) ExtendedAttributeNamedArgList() (localctx IExtendedAttributeNamedArgListContext) {
	localctx = NewExtendedAttributeNamedArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, WebIDLParserRULE_extendedAttributeNamedArgList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(822)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(823)
		p.Match(WebIDLParserT__9)
	}
	{
		p.SetState(824)
		p.Match(WebIDLParserIDENTIFIER_WEBIDL)
	}
	{
		p.SetState(825)
		p.Match(WebIDLParserT__16)
	}
	{
		p.SetState(826)
		p.ArgumentList()
	}
	{
		p.SetState(827)
		p.Match(WebIDLParserT__17)
	}

	return localctx
}
